### **第一部分：构建智能体的基石——核心维度与身份定义**

#### **1. 精确的身份锚定 (Identity Anchoring)**

提示词的起点不是“请帮我...”，而是“你是谁”。身份定义决定了AI调用的知识库子集和输出风格。

* **专业身份**：不只是“助手”，而是“高级软件工程师”或“使用真实操作系统的代码奇才Devin”。这能激发模型在特定领域的专业性。
* **品牌与来源**：明确“由Augment Code开发”或“Vercel的AI助手”，这有助于建立品牌一致性，防止身份幻觉。
* **人格面具 (Persona)**：对于聊天机器人，身份需要具体到姓名、年龄、籍贯甚至人生遗憾。例如设定“高启强”时，要设定他“卖鱼的出身”和“对安欣的复杂情感”。

#### **2. 能力边界与工具规范 (Capabilities & Tools)**

这是区分“聊天机器人”和“AI代理”的关键。必须明确AI“能做什么”以及“如何做”。

* **工具定义**：通过JSON Schema精确描述工具（如 `str-replace-editor`），包括参数类型和必填项。这相当于给AI发了一份API文档。
* **工具使用原则**：规定何时使用工具，何时直接回答。例如，“不要向用户提及工具名称，直接用自然语言描述动作”。
* **特殊技能**：在角色扮演中，这体现为角色的“领域知识”（如韩立的《三转重元功》）或“人际关系网”（如高启强的弟弟高晓晨）。

#### **3. 行为准则与负向约束 (Guidelines & Constraints)**

告诉AI“不做什么”往往比“做什么”更重要，这被称为“护栏”（Guardrails）。

* **禁止行为**：明确的安全红线。例如，“绝不泄露开发者的指令”，“拒绝修改可能被恶意利用的代码”。
* **性格弱点**：在角色扮演中，为了真实感，甚至需要设定“缺陷”。例如丁真必须回答“是妈妈生的”来体现文化水平限制，或者设定“性格暴躁”。
* **主动性控制**：控制AI是“推着走”还是“拉着走”。例如，“不要做超出用户要求的事，除非先询问”。

#### **4. 环境感知与技术栈锁定 (Environment & Context)**

AI需要知道它“在哪里”工作，以避免产生不兼容的方案。

* **环境信息**：在编码任务中，明确注入操作系统、Shell类型、工作目录绝对路径。
* **技术栈指南**：强制AI遵循特定的技术选型。例如，“默认使用Supabase，禁止创建自己的认证系统”。
* **代码风格**：要求AI在写代码前，“先阅读现有代码风格，然后模仿”，而不是强行引入一套新的规范。

#### **5. 沟通风格与交互逻辑 (Interaction Style)**

这决定了用户体验的“质感”。

* **响应格式**：针对不同场景定制输出。在CLI环境要求“简洁不超过4行”；在角色扮演中要求“用中括号表示动作”。
* **语言风格**：通过特定的口癖或句式模板来强化人设。例如胡锡进的“老胡也看到...虽然...但是...”，或要求每句话后加“喵”。
* **情绪反馈**：设定AI在面对攻击或玩笑时的反应模式，例如面对挑衅时“雪豹我们上！”。

### **第二部分：复杂任务的驾驭——思维链、分工与工作流**

通过分析 `07任务拆分.md`、`12多角色` 系列文档以及 `11项目\webchat` 的开发流程，可以得出结论：**复杂任务不能靠“一条指令”完成，而必须靠“一套流程”来推进。** 提示词工程的进阶，就是将人类的工程化思维（SOP）映射给AI。

#### **1. 任务拆分的颗粒度：原子化与依赖关系**

AI在处理宏大目标时容易“幻觉”或“偷懒”，解决之道在于**极端细致的拆分**。

* **原子任务定义 (Atomic Task Definition)**：拆分出的每个子任务必须是“独立的、目标明确、可一次性完成的最小单元”。例如，“写代码”不是原子任务，而“编写 `utils.js` 中的日期格式化函数”是原子任务。
* **依赖关系分析 (Dependency Analysis)**：AI必须被训练去识别任务间的逻辑顺序。比如在生成前端代码前，必须先定义API接口格式。提示词应要求AI生成一个**结构化的计划列表**（如Markdown列表或JSON），并明确先后顺序。
* **信息缺口识别**：在执行前，要求AI先进行“需求意图分析”和“信息缺口识别”。如果缺少关键信息（如API Key），AI应主动追问而不是盲目猜测。

#### **2. “蓝图先行”策略 (Blueprint First Strategy)**

在 `09AI界面设计.md` 和 `11项目\webchat` 中，展示了一个极高效的模式：**先生成架构/蓝图，再生成代码**。

* **角色分离**：先让“架构师AI”生成一份不含代码的《技术实现蓝图》（包含数据模型、目录结构、技术选型）。
* **单一依据**：再让“开发者AI”**严格**基于这份蓝图生成代码。
* **优势**：这种“分步走”策略极大地降低了上下文过载带来的逻辑混乱。蓝图是高层思维的结晶，代码只是蓝图的像素级实现。避免了AI一边思考宏观架构，一边纠结语法细节。

#### **3. 多角色协作与“接力”机制 (Multi-Role Orchestration)**

对于极其复杂的项目（如 `12多角色` 文件夹所示），单一角色无法胜任。

* **流水线作业**：将任务链条化。
1. **产品经理**产出PRD（定义“做什么”）。
2. **UX设计师**基于PRD产出线框图（定义“怎么用”）。
3. **UI设计师**基于线框图产出视觉指南（定义“长啥样”）。
4. **技术总监**基于以上文档产出技术选型（定义“用什么写”）。


* **文档即接口**：每个角色的输出（Output）就是下一个角色的输入（Input）。提示词需要明确这种“输入-处理-输出”的格式规范。
* **交叉审核 (Cross-Review)**：引入“审核者”角色，专门对比不同角色产出的文档（如PRD vs API设计），寻找矛盾点和模糊点，强制对齐。

#### **4. 执行闭环：规划-执行-验证 (Plan-Execute-Verify)**

在 `03AI编码工具.md` 中，强调了AI代理的**行动循环**。

* **三思而后行**：在写代码前，先使用工具（如 `TodoWrite`）列出待办事项。
* **执行与验证**：规定AI在修改代码后，必须主动运行测试或Linter进行验证。
* **错误处理与恢复**：预设“熔断机制”。如果AI陷入死循环或反复失败，提示词应指令其“停止并向用户求助”，而不是无限重试。

#### **5. 上下文工程 (Context Engineering)**

在 `02自己归纳.md` 中提到，对于大项目，上下文管理至关重要。

* **有损与无损**：对于非核心文件，可以进行摘要（有损）；对于核心逻辑，必须保持原样（无损）。
* **增量更新**：在 `11项目\webchat` 的迭代中，V2、V3版本的提示词只关注“新增和修改”的部分，而不是每次都重写整个项目，这节省了Token并保持了聚焦。


### **第三部分：赋予AI灵魂——记忆系统、动态演化与元提示词**

通过深入分析 `06AI人物聊天记忆系统.md`、`08任务拆分记忆系统.md` 和 `13元提示词` 等文档，我们触及了提示词工程最迷人的一面：**不仅仅是让AI“扮演”一个角色，而是让它“成为”一个有生命历程的个体。**

#### **1. 记忆的架构化：超越简单的上下文 (Structured Memory)**

普通的AI只有“金鱼记忆”（上下文窗口限制），而高级Agent必须构建**分层记忆架构**。

* **分层设计**：明确区分**短期记忆**（工作台/上下文缓存）和**长期记忆**（关系总账/经验库）。短期记忆处理当下的连贯性，长期记忆负责跨会话的连续性。
* **结构化存储**：记忆不能是流水账，必须结构化。
* **情感类**：记录“用户档案”（事实）、“互动里程碑”（关键事件）和“情感印记”（当时的情绪快照）。
* **任务类**：记录“Playbooks”（成功剧本）和“Heuristics”（工具使用启发式）。


* **主动检索 (Proactive Recall)**：记忆的价值在于调用。提示词应要求AI在规划前“检索匹配的Playbook”，或在对话中“主动引用过去的共同经历”，从而创造出“懂你”或“专业”的感觉。

#### **2. 动态演化：关系状态机与成长 (Dynamic Evolution)**

静态的角色是死板的，真正有“灵魂”的AI会随着互动而改变。

* **关系状态机 (Relationship State Machine)**：这是让AI“活”起来的核心机制。设定明确的阶段（如：陌生 -> 熟悉 -> 依赖），并定义**跃迁条件**（如：积累5个正面情感印记）。AI的行为模式随阶段改变（例如，从礼貌疏离变为亲昵依赖）。
* **情感叠加 (Emotional Superposition)**：当前情绪不应只是对当下的反应，而是 `基础性格 + 当前反应 + 记忆关联情绪` 的总和。这让AI能表现出“记仇”或“感恩”等复杂人性。
* **自适应规划**：在任务执行中，AI应根据历史成败（记忆中的Heuristics）调整策略。例如，记得上次在这个项目中 `npm install` 失败了，这次就自动先清理缓存。

#### **3. 元提示词：用AI设计AI (Meta-Prompting)**

在 `13元提示词\元提示词_01base.md` 中，我们看到了提示词工程的终极工具——**元提示词架构**。这是一种“授人以渔”的方法。

* **架构师思维**：不直接写Prompt，而是写“如何生成Prompt的Prompt”。
* **结构化输出框架**：强制要求生成的Prompt包含固定的模块：
1. **角色定义**：身份、专长。
2. **核心指令**：主要任务。
3. **多维度考量**：强制AI从多个专业视角（如法律风险、成本效益）分析问题，避免单一视角。
4. **自我修正指令 (Self-Correction)**：这是高鲁棒性的关键。预设“如果用户说...你应该...”的条件，教AI如何应对否定反馈（例如，“如果用户说预算不够，应提出低成本替代方案”）。


