# 📝 AI 辅助开发 SOP：新增功能 (Add a Feature) 检查表

**文档目标：** 规范 AI 辅助引入新功能的流程，确保在不破坏现有系统稳定性的前提下，实现精准、高效的功能集成，杜绝“面条代码”和“上下文污染”。

## 阶段一：需求对齐与上下文封装 (Planning & Context)

*目标：明确“做什么”，并为 AI 准备纯净、高信息密度的执行上下文。*

* **[ ] 1. 明确需求意图与验收标准 (DoD)**
* **定义用户故事：** 明确该功能解决的具体痛点（例：作为用户，我希望在局域网聊天时能一键发送本地文件）。
* **定义验收标准：** 列出 3-5 条清晰的、可测试的边界条件（例：断网时的提示、文件大小限制等）。


* **[ ] 2. 构建精准上下文 (Context Engineering)**
* **无损注入 (核心依赖)：** 挑选与新功能强相关的 1-3 个核心源文件（如相关的视图层代码、状态管理逻辑），全文提供给 AI。
* **有损注入 (外围关联)：** 提取外围依赖的接口定义、数据模型 (Schema) 或路由配置的摘要提供给 AI，避免超过 Token 限制导致逻辑遗忘。
* **环境对齐：** 明确当前的开发环境设定（例：是在 Ubuntu 下运行，涉及 Docker 容器的启停，还是在 IntelliJ IDEA 中进行调试）。



## 阶段二：架构评估与蓝图设计 (Architecture & Blueprint)

*目标：在写代码前，先让 AI 充当“架构师”，完成技术选型与文件级规划。*

* **[ ] 3. 依赖与影响范围评估**
* **第三方库引入：** 询问 AI 是否需要引入新的包。如果需要，强制要求其使用标准的包管理器命令（如 Flutter 的 `flutter pub add` 或 Node 的 `npm install`），严禁手动修改配置文件。
* **技术栈契合度：** 确认新引入的逻辑是否符合当前项目的技术底座（如 Capacitor、Neutralino 或是具体的跨端框架规范）。


* **[ ] 4. 输出结构化文件清单 (File Roadmap)**
* 要求 AI 输出详尽的操作清单，明确区分 **【创建】** 与 **【修改】**。
* **示例要求：**
* `【创建】/src/services/dify_api.ts` - 封装对接 Dify 知识库的请求逻辑。
* `【修改】/src/store/chat_state.dart` - 新增 AI 思考状态 (isThinking) 的字段。





## 阶段三：原子化任务执行 (Atomic Execution)

*目标：化整为零，将蓝图转化为代码，确保代码风格统一且可控。*

* **[ ] 5. 代码风格嗅探与对齐**
* 在下发代码生成指令前，强制加入规则：“请先阅读当前提供的源文件，模仿现有的变量命名规范、注释风格（如 Google Style Guide）和错误处理模式。”


* **[ ] 6. 核心逻辑原子化生成**
* **后端/数据层优先：** 先让 AI 生成数据模型、API 接口定义或本地数据库的迁移脚本。
* **前端/视图层其次：** 基于已确认的数据接口，生成 UI 组件和交互逻辑。
* **拒绝一次性大段输出：** 对于复杂功能（如带有 AI 智能笔记的聊天面板），要求 AI 分步骤生成，写完视图层后暂停，等你确认后再写状态管理逻辑。



## 阶段四：验证、提交与记忆沉淀 (Verification & Memory)

*目标：确保功能可用，并通过 Git 和 AI 记忆系统固化本次开发经验。*

* **[ ] 7. 代码审查与本地验证**
* 将 AI 生成的代码粘贴进项目后，观察 IDE 是否有语法报错。
* 运行项目，对照阶段一的“验收标准”进行测试。如果有 Bug，收集完整的报错堆栈日志喂给 AI，要求其先做“根因分析”，再给修复方案。


* **[ ] 8. 规范化提交 (Git Commit)**
* 确保该功能的修改被打包在一个语义化明确的 Commit 中（例：`feat: 增加局域网文件传输底层通信逻辑`），作为安全的“存档点”。


* **[ ] 9. 经验沉淀 (Update Memory)**
* **复盘对话：** 如果在此次功能开发中，发现 AI 对某个特定框架的理解有偏差，或者提炼出了极其好用的交互方式，将这段经验记录到你的“项目专属 Prompt”或 AI 的记忆总账中（Heuristics/Playbooks）。



