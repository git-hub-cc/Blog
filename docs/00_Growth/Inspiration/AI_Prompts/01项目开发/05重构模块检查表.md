### 模块重构标准检查表 (Refactoring Checklist)

#### 一、 启动前评估 (Pre-flight Assessment)

重构前必须明确“为什么重构”以及“影响面有多大”，切忌为了重构而重构。

* **[ ] 明确重构目标：** 确定本次重构的核心诉求是提升可读性、降低耦合度、优化性能，还是为了后续的新功能（如接入新的 AI 模型或复杂的局域网通信逻辑）铺路。
* **[ ] 圈定“爆炸半径”：** 梳理出该模块的上下游依赖关系。明确指出哪些文件必须修改，哪些文件绝对不能触碰。
* **[ ] 评估重构时机：** 确认当前模块没有正在进行的紧急 Bug 修复或并发的新功能开发，避免代码合并冲突。

#### 二、 构建安全网 (Building the Safety Net)

在没有安全网的情况下重构无异于走钢丝。这是给 AI 划定边界的关键前提。

* **[ ] 建立基线分支：** 在 Git 中基于稳定的主干切出一个专门的重构分支（如 `refactor/module-name`），确保随时可以回滚。
* **[ ] 清理并统一环境：** 确保本地运行环境整洁。如果是容器化应用，停止并删除所有旧的 Docker 容器，重新构建干净的镜像，确保重构前后的环境一致性。
* **[ ] 确认测试覆盖率：** 核心业务逻辑必须有单元测试或集成测试覆盖。如果原有代码缺乏测试，重构的第一步是**先写测试用例**，将其作为重构的验证锚点。

#### 三、 执行阶段：微观与中观拆解 (Execution)

不要让 AI 一次性重写整个文件，而是将重构动作原子化。

* **[ ] 优先使用 IDE 工具：** 对于基础的变量重命名、方法提取、类移动等操作，优先使用 IntelliJ IDEA 等现代 IDE 的内置重构功能，这些工具基于抽象语法树 (AST)，比大模型直接生成文本更安全可靠。
* **[ ] 分离 UI 与业务逻辑：** 检查模块中是否存在视图层与业务逻辑层深度耦合的情况。将数据请求、状态管理提取到独立的 Controller 或 Service 层，保持 UI 组件的纯粹性。
* **[ ] 消除“代码异味” (Code Smells)：** 识别并消除过长的方法、过大的类、深层嵌套的 `if-else` 以及重复的魔法数字/字符串。
* **[ ] 实施原子化提交：** 每一个微小的重构步骤（如“提取日期格式化函数”）完成后，立即运行测试并进行一次 Git 提交。确保每一步的代码都是可编译、可运行的。

#### 四、 验证与收尾 (Validation & Delivery)

重构的终极标准是“外部行为保持不变”。

* **[ ] 自动化测试回归：** 运行所有相关的测试用例，确保没有任何测试因重构而挂掉。
* **[ ] 性能与资源基准比对：** 检查重构后的模块是否存在内存泄漏，或者处理大体积数据（如文件流传输）时 CPU 占用率是否出现异常飙升。
* **[ ] 交叉代码审查 (Code Review)：** 将重构前后的差异（Diff）提交给团队成员或作为一个独立的 Prompt 提交给 AI，重点审查是否无意中改变了边界条件的处理逻辑。
* **[ ] 更新相关文档：** 如果重构改变了内部接口、数据结构或组件调用方式，同步更新项目的架构文档或 API 说明。

---

### 给 AI 的“重构护航”元提示词 (Meta-Prompt)

当你准备把某个复杂文件丢给 AI 进行重构时，可以直接使用以下提示词模板约束它的行为：

> **角色：** 你是一位严谨的高级软件架构师，擅长在不改变代码外部行为的前提下优化代码内部结构。
> **任务：** 我需要对提供的代码进行重构。
> **核心纪律：**
> 1. **无损原则：** 绝对不能改变现有业务逻辑、删除现有特性或修改对外暴露的 API 契约。
> 2. **渐进式方案：** 不要直接吐出重构后的完整代码。请先阅读代码，指出 3 个最核心的“代码异味”，并列出一个分步骤的重构计划。
> 3. **单一职责：** 你的计划应当聚焦于分离 UI 组件与底层状态逻辑，或者提取重复的工具函数。
> 
> 
> 请输出你的分析和分步重构计划，等待我确认后，我们再一步步执行代码修改。

