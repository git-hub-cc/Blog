## 🚀 AI 辅助开发：新项目启动检查表 (SOP)

**核心原则：** 蓝图先行，拒绝直接生成代码。通过扮演不同专业角色，分阶段固化项目上下文。

### 阶段一：需求与愿景对齐 (产品经理视角)

本阶段的目标是明确“做什么”和“不做什么”，圈定最小可行性产品 (MVP) 的边界。

* [ ] **一句话愿景定义：** 清晰描述产品的核心价值。（例如：一款集成笔记功能、支持 Dify 接口调用以及局域网文件传输的跨平台 AI 聊天工具。）
* [ ] **明确目标用户与核心痛点：** 描述该工具主要解决什么问题，供 AI 理解业务逻辑的优先级。
* [ ] **划定 MVP 功能边界：** 强制拆分功能阶段，避免大而全。明确第一阶段的核心里程碑。（例如：MVP 阶段是优先跑通基于 Dify 的 AI 对话逻辑，还是先实现局域网的节点发现与文件传输？）
* [ ] **生成并确认 PRD：** 引导 AI 以“产品经理”身份输出一份一页纸的 PRD (包含核心用户故事和验收标准)，由人工进行严格审查和确认。

### 阶段二：技术蓝图与架构设计 (架构师视角)

本阶段的目标是敲定技术选型、系统架构和核心数据流向，形成后续 AI 编写代码的“宪法”。

* [ ] **确认核心技术栈选型：** 明确前端、后端、跨平台方案及存储方案，绝不允许 AI 自由发挥。（例如：明确前端使用 Flutter，或基于 Capacitor / Neutralino 的前端框架；明确采用 SQLite 还是其他本地存储方案。）
* [ ] **定义全局目录树结构：** 要求 AI 输出完整的项目文件结构草图，明确业务组件、公共工具类、状态管理、路由等模块的存放位置。
* [ ] **核心数据模型与 API 契约：** 针对 PRD 中的核心功能，提前定义数据库表结构 (Schema) 或前后端/本地通信的接口格式 (JSON 契约)。
* [ ] **生成技术蓝图文档：** 将上述选型和设计固化为一份 `Architecture.md` 文档，作为后续所有开发 Prompt 的强制上下文。

### 阶段三：规范确立与工程基建 (DevOps/环境视角)

本阶段的目标是统一代码风格，梳理开发环境，消除“在我的电脑上跑不起来”的隐患。

* [ ] **锁定操作系统与环境依赖：** 明确项目的主要开发和运行环境。（例如：基于 Ubuntu 系统，明确所依赖的 Node.js/Dart 版本，以及 Docker 容器的编排方式。）
* [ ] **制定代码规范与风格指南：** 指定通用的代码规范（如 Google Style Guide），并明确注释要求、命名约定（驼峰/蛇形等）。
* [ ] **初始化开发工具配置：** 生成用于统一团队或 AI 行为的配置文件。（例如：`.gitignore`、`.editorconfig`、针对 IntelliJ IDEA 的代码格式化配置、Git 提交信息规范。）
* [ ] **跑通 Hello World：** 在本地环境中执行初始化命令，确保空项目能够成功编译运行，为后续的迭代提供一个干净的基线 (Baseline)。

### 阶段四：原子任务拆分与执行调度 (技术负责人视角)

本阶段的目标是将宏观架构转化为机器和人类都可以无脑执行的待办事项。

* [ ] **进行模块化任务拆分：** 要求 AI 基于前面的 PRD 和技术蓝图，将整个项目拆分为多个独立的功能模块。
* [ ] **定义原子化任务：** 将每个模块继续向下拆分，直到每个任务都是“单一职责、可在一次 Prompt 内完成且可独立验证”的原子任务。
* [ ] **梳理任务依赖关系：** 明确任务的先后执行顺序，哪些必须串行（如：先建数据库模型，再写查询逻辑），哪些可以并行。
* [ ] **输出执行检查单：** 让 AI 使用 Markdown 列表输出这份完整的 `Task-List.md`，并在每个任务后附带验收标准。

---

### 使用建议

在实际操作中，不要试图在一个对话窗口里完成这四个阶段。建议你：

1. 开一个专门的“架构师”对话窗口，跑完前三个阶段。
2. 将得到的 `PRD.md`、`Architecture.md` 和 `Task-List.md` 保存到本地。
3. 在开始具体的编码时，开一个全新的“程序员”对话窗口，把具体的原子任务和相关的上下文喂给 AI，让它专注写代码。

你想尝试用这个检查表的结构，为你目前正在构思的项目跑一次“阶段一：需求与愿景对齐”吗？我们可以直接从定义 MVP 开始。