### 一、 上下文工程检查表 (Context Engineering Checklist)

上下文工程的核心是**“定界”与“喂料”**：明确 AI 所在的物理和软件环境，并以最高效的信噪比提供背景知识。

**1. 环境与基座感知 (Environment Baseline)**

* [ ] **操作系统与底层环境：** 是否已告知 AI 当前的执行环境？（例如：明确是在 Ubuntu 系统下运行，桌面环境为 GNOME，是否存在双系统文件路径差异？）
* [ ] **开发工具链：** 是否说明了正在使用的主要工具？（例如：使用 IntelliJ IDEA 作为代码编辑器，使用 Git 进行版本控制。）

**2. 技术栈与边界锁定 (Tech Stack Constraints)**

* [ ] **核心技术选型：** 是否明确了主框架和辅助框架？（例如：当前开发的是 Flutter 项目，还是使用了 Capacitor 或 Neutralino 构建应用？）
* [ ] **环境依赖约束：** 是否限制了 AI 的操作范围？（例如：要求 AI 提供通过 Docker 管理环境的方案，而不是直接在宿主机乱装依赖。）
* [ ] **禁止事项 (Guardrails)：** 是否明确告诉了 AI “绝对不要碰什么”？（例如：禁止修改特定的配置文件，禁止擅自引入新的第三方包。）

**3. 信息精度分配 (Lossy vs. Lossless)**

* [ ] **无损上下文 (核心区)：** 当前正在修改的特定函数、核心业务逻辑、数据库 Schema 是否已完整、原样地提供给了 AI？
* [ ] **有损上下文 (外围区)：** 庞大的非核心文件、旧版本的长对话、历史文档，是否已经通过摘要或架构描述的形式精简提供，以节省 Token 并防止注意力分散？

---

### 二、 记忆系统检查表 (Memory System Checklist)

记忆系统的核心是**“状态”与“经验”**：让 AI 知道当前走到哪一步了，以及如何利用过往的成功或失败经验。

**1. 短期工作区状态 (Short-Term / Working Memory)**

* [ ] **当前任务快照：** AI 是否清楚当前的“绝对目标”是什么？（例如：“我们现在的唯一目标是让这个 Flutter 页面无报错地渲染出来，暂时不考虑 UI 美化。”）
* [ ] **上下文连贯性：** 是否总结了刚才已经尝试过且失败的路径？（防止 AI 再次给出同样的错误建议，陷入死循环。）
* [ ] **当前进度锚点：** 我们在整个执行计划板（TODO 列表）上的哪个位置？

**2. 长期经验法则 (Heuristics & Playbooks)**

* [ ] **过往排错经验 (Heuristics)：** 是否需要唤醒特定的排错记忆？（例如：“记住，上次遇到类似 Capacitor 构建失败时，是因为缓存没清，这次请优先考虑缓存清理方案。”）
* [ ] **操作 SOP (Playbooks)：** 是否需要调取特定的标准流程？（例如：“请按照我们之前约定的‘复现-定位-修改-测试’标准修复流程来处理这个 Bug。”）

**3. 项目特定知识图谱 (Project-Specific Context)**

* [ ] **项目架构认知：** AI 是否理解当前项目的独特目录结构和模块划分？
* [ ] **命名与风格惯例：** 是否提供了当前项目的代码规范或特定命名风格，以确保 AI 生成的代码能无缝融入？

**4. 协作偏好设定 (User Preference Profile)**

* [ ] **沟通与输出偏好：** 是否明确了你期望的输出格式？（例如：要求只输出核心代码差异，或者要求在执行有风险的 Docker 容器清理命令前，必须先列出计划并等待确认。）

