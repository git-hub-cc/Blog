### 一、 意图解析检查表 (Intent Resolution Checklist)

在写下第一行代码或给出第一个执行指令之前，请先对照以下问题，确保“做正确的事”。

#### 1. 核心目标与价值 (Goal & Value)

* [ ] **剥离表象寻找本质**：这个需求表面上是要“加一个按钮/页面”，实际上是为了解决用户的什么痛点？达成什么商业/业务目标？
* [ ] **受众定位**：谁会使用这个功能？他们的技术背景、使用场景和主要诉求是什么？

#### 2. 上下文与现状感知 (Context & Status)

* [ ] **环境锚定**：当前涉及的技术栈、框架版本、操作系统环境是否已明确定义？
* [ ] **历史包袱评估**：要修改的模块是否有历史遗留问题？是否存在强耦合的旧逻辑需要特别避开或兼容？
* [ ] **设计语言与规范**：是否有既定的 UI 规范、代码风格指南（如 Google Style Guide）需要严格遵守？

#### 3. 边界、约束与缺口 (Boundaries, Constraints & Gaps)

* [ ] **硬性约束确认**：有哪些绝对不能跨越的红线？（例如：禁止引入新的第三方依赖、API 响应时间不得超过 200ms、不允许修改核心数据库 Schema）。
* [ ] **信息缺口排查**：要完成这个目标，我现在手头还缺什么关键信息？（例如：缺失的接口文档、未敲定的字段定义、未提供的授权密钥）。

#### 4. 成功定义 (Definition of Done - DoD)

* [ ] **可量化的验收标准**：做到什么程度算真正完成？有哪些明确的客观指标或行为表现可以证明任务成功？

---

### 二、 原子化拆分检查表 (Atomic Decomposition Checklist)

当意图明确后，将宏大的目标拆解为机器（或初级开发者）能够无脑执行的最小单元。

#### 1. 原子性检验 (Atomicity)

* [ ] **单一职责原则**：这个子任务是否只做“一件”事？（如果任务描述中包含“并且/或者/然后”，说明它还需要继续拆分）。
* [ ] **独立闭环**：这个子任务的输入和输出是否清晰？是否可以在不依赖后续任务的情况下独立完成和测试？

#### 2. 依赖与执行路径 (Dependencies & Routing)

* [ ] **前置条件梳理**：执行这个任务前，必须先完成哪些任务？（例如：写前端 UI 前，必须先定义好后端的 API 数据结构）。
* [ ] **并行化挖掘**：列表中有哪些任务是互不干扰的？（可以交给多个 AI Agent 或在不同的终端并行处理以节省时间）。

#### 3. 执行工具与动作映射 (Tooling & Actions)

* [ ] **工具对口**：明确完成这个原子任务需要调用什么具体动作或工具？（例如：是使用 `grep` 搜索文件，还是使用 `npm` 安装依赖，亦或是直接编辑某个 `.dart` 文件）。

#### 4. 验证与兜底 (Verification & Fallback)

* [ ] **验证锚点设置**：每完成一个原子任务，用什么具体命令或方法来验证结果的正确性？（例如：运行指定的单元测试、检查编译日志是否有警告）。
* [ ] **风险预判与 Plan B**：如果这步执行失败（如网络超时、遇到无法解决的版本冲突），退路是什么？是否有清理环境、回滚代码的预案？

---

