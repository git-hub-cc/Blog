### 支柱三：多维度记忆架构与状态机 (Memory & Dynamic Evolution) 检查表

这个阶段的核心目标是：**打破大模型的“金鱼记忆”，赋予它跨越单次会话的连贯性、成长性，以及对特定项目和你的专属“默契”。**

#### 1. 短期缓存 / 工作台记忆 (Short-Term / Workbench Memory)

* [ ] **滑动窗口强制回顾：** 是否明确指示大模型在每次回复前，主动提取最近几轮对话的核心上下文？（例如：在连续调试复杂的网络构建问题时，确保 AI 牢记上一轮刚修改过的配置文件，而不是给出相互矛盾的建议）
* [ ] **任务状态快照 (Snapshot)：** 当前正在执行的任务是否有明确的状态标记？（例如：要求 AI 在每轮输出前，先打印当前处于“Bug 定位阶段”还是“代码验证阶段”，防止其在长对话中迷失目标）
* [ ] **动态环境缓存：** 是否让 AI 缓存了你当前的操作环境进度？（例如：记录你刚刚已经停止并删除了所有 Docker 容器，确保下一步的指令是基于一个干净的环境）

#### 2. 长期关系总账 / 经验知识库 (Long-Term Memory)

* [ ] **高优偏好捕获 (User Profile)：** 是否设计了机制，让 AI 悄悄记录你的开发习惯？（例如：一旦你明确了某个项目是在 Ubuntu 下使用 IntelliJ IDEA 开发，AI 就会将此作为长期记忆，后续不再给出 Windows 相关的路径或快捷键建议）
* [ ] **项目里程碑记录 (Milestones)：** 是否有指令要求 AI 总结并“记住”已完成的关键节点？（例如：在开发聊天应用时，当“局域网文件传输”或“Dify 接口对接”等核心功能跑通后，要求 AI 必须在后台生成一条成功日志或架构级记忆标签）
* [ ] **启发式经验沉淀 (Heuristics)：** 任务失败并最终解决后，是否强制 AI 进行复盘？（例如：总结某次特殊的依赖冲突是如何通过清理特定缓存解决的，并将其提炼为未来遇到类似报错时的首选排查方案）

#### 3. 静态世界观与背景知识 (Static Knowledge / RAG)

* [ ] **领域知识外挂：** 你的提示词系统是否接入了特定项目的基础设定文档？（例如：无论讨论哪个功能模块，AI 都必须时刻对齐你的核心产品愿景——这是一个集成了笔记记录、AI 功能的聊天应用，确保它给出的功能建议不会偏离产品主轴）
* [ ] **知识优先级防篡改：** 是否设定了最高优先级的知识铁律？（例如：明确规定“所有关于本项目的架构决策，必须严格以我提供的设定文档为准，绝不允许即兴编造或引入未批准的第三方服务”）

#### 4. 记忆操作与状态演化 (Memory Mechanics & State Machine)

* [ ] **显式/隐式写入触发器 (Ingestion)：** 是否定义了 AI 何时应该主动“记笔记”？（例如：规定当对话中出现强烈的肯定反馈，或确认了某个架构决策时，AI 需在内心生成结构化的 `[记忆写入]` 日志）
* [ ] **记忆关联与提取 (Retrieval)：** 是否鼓励 AI 主动使用过去的记忆？（例如：遇到新需求时，引导 AI 说出“根据之前我们设计的笔记模块数据结构，这个新功能可以这样复用……”以建立深度协作感）
* [ ] **状态机跃迁 (State Machine)：** AI 的行为模式是否会根据项目阶段或记忆累积发生改变？（例如：在项目从 0 到 1 的起步阶段，AI 处于“发散建议”状态；当 MVP 雏形确立后，进入“严谨收敛”状态，以极高的要求审视新功能的加入，防止过度膨胀）

---
