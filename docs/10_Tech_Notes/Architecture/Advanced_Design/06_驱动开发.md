# 驱动开发

本文汇总以"测试/行为"为驱动力的开发方法，包含：TDD（测试驱动开发）、BDD（行为驱动开发）。

---

## 一、测试驱动开发（TDD）

### 引言
TDD并不是单一、僵化的实践，而包含了多种思想流派和应用范围。其核心理念始终是**红-绿-重构（Red-Green-Refactor）**：先写测试，再写实现，最后重构。

### 按思想流派划分：经典派 vs 模拟派

| 特点         | 经典派（Classicist / 芝加哥/底特律学派） | 模拟派（Mockist / 伦敦学派）       |
| ------------ | ---------------------------------------- | ---------------------------------- |
| **驱动方式** | 由内而外（Inside-Out）                   | 由外而内（Outside-In）             |
| **测试焦点** | 状态验证（操作后状态是否正确）           | 行为验证（是否正确调用了依赖）     |
| **依赖处理** | 倾向使用真实对象，只在必要时用Stub/Fake  | 广泛使用Mock隔离被测单元           |
| **设计影响** | 自然演进，可能需要额外重构来解耦         | 强制解耦，驱动面向接口的设计       |
| **测试粒度** | 单元测试可包含多个协作类                 | 严格单元，只测一个类               |
| **优点**     | 测试更真实，信心足，易上手               | 隔离性强，速度快，驱动良好设计     |
| **缺点**     | 隔离性差，速度慢，可能耦合               | 过度Mock风险，集成风险，学习曲线陡 |

### 按开发流程和目标划分

#### ATDD（验收测试驱动开发）
- **目标**：确保软件功能符合业务需求和用户预期
- **流程**：业务/开发/测试共同定义可执行的验收标准 → 转化为自动化验收测试 → 用传统TDD实现
- **特点**：ATDD是外层大循环（业务价值驱动），TDD是实现这个大循环的内层小循环

#### BDD（行为驱动开发）
可看作ATDD和TDD的精炼结合，强调 **Given-When-Then** 语法（Gherkin）描述场景。

#### SDD（规范驱动开发）
更宽泛的概念，BDD是其最著名的形式。强调测试即规范，每个测试用例是对系统某行为的精确可执行描述。

### 按测试范围和粒度划分

| 类型          | 范围                                            | 周期    | 工具                            |
| ------------- | ----------------------------------------------- | ------- | ------------------------------- |
| **单元TDD**   | 最小可测试单元（函数、类）                      | 秒~分钟 | JUnit, NUnit, PyTest + Mock框架 |
| **集成TDD**   | 多模块协同工作（Controller→Service→Repository） | 小时/天 | 需初始化数据库、启动部分服务    |
| **端到端TDD** | 完整业务流程，从用户视角出发                    | 分钟级+ | Selenium, Cypress, Playwright   |

### 按应用领域划分

- **后端TDD**：API、微服务、业务逻辑、数据访问层（最成熟）
- **前端TDD**：UI组件、状态管理（组件单元测试→交互测试→E2E测试）
- **IaC TDD**：基础设施即代码（Terraform, Ansible），使用 Terratest, Kitchen-CI
- **数据科学/ML TDD**：数据验证、管道逻辑、模型契约测试、模型性能测试

### 选择策略
- **混合是常态**：通常从BDD场景开始（模拟派思路），驱动出API接口，实现核心业务逻辑时采用经典派TDD
- **算法/领域核心组件** → 经典派TDD更直观
- **与多依赖协作的编排组件**（Controller, Service）→ 模拟派TDD更能驱动清晰接口

---

## 二、行为驱动开发（BDD）

### 摘要
BDD是一种敏捷软件开发方法，通过**具体、可执行的示例**来定义系统行为，构建**共享理解**，并以此驱动开发过程。

### 三大核心原则

#### 1. 以协作为核心（"三剑客"会议）
- **业务人员**：定义"我们想要什么"
- **开发人员**：关注"我们如何构建它"
- **测试人员**：发现边缘情况和潜在问题

#### 2. 以通用语言为桥梁
使用 **Gherkin 语言**（Given-When-Then）作为所有参与者共享的无歧义语言：
- **Given（给定）**：初始上下文或前置条件
- **When（当）**：用户执行的动作或事件
- **Then（那么）**：预期的结果

```gherkin
Feature: ATM 取款
  Scenario: 账户余额充足时成功取款
    Given 我的银行卡账户中有 1000 元余额
    When 我请求取出 200 元
    Then 我应该收到 200 元现金
    And 我的银行卡账户余额应为 800 元
```

#### 3. 以实例为驱动
- **具体化**：用具体例子代替模糊描述
- **可执行化**：例子被编写成可由BDD框架自动执行的测试脚本
- **文档化**：构成"活文档"，与代码同步更新

### BDD 工作流程：发现 → 定义 → 自动化

1. **发现（Discovery）**："三剑客"会议，发掘具体行为、规则和边界条件，达成共识
2. **定义（Definition）**：用Gherkin语言编写 `.feature` 文件
3. **自动化（Automation）**：开发人员将Gherkin步骤与步骤定义代码（Step Definition）关联，形成自动化测试套件

### BDD 与其他方法的关系

| 特性     | BDD                        | TDD                    |
| -------- | -------------------------- | ---------------------- |
| 核心焦点 | 系统**行为**               | 代码**单元**           |
| 驱动力   | 业务价值和用户需求         | 技术实现和代码质量     |
| 编写语言 | 自然语言（Gherkin）        | 代码（JUnit等）        |
| 参与者   | 整个团队（业务/开发/测试） | 开发者                 |
| 视角     | 由外而内（Outside-In）     | 由内而外（Inside-Out） |

**BDD vs ATDD**：BDD是ATDD的具体实现方式，更强调协作过程、通用语言，并提供了Gherkin标准化语法。所有BDD都是ATDD，但并非所有ATDD都是BDD。

### 主要框架工具

| 语言       | 框架                       |
| ---------- | -------------------------- |
| Java       | Cucumber-JVM, JBehave      |
| .NET       | SpecFlow                   |
| Python     | Behave, pytest-bdd         |
| JavaScript | Cucumber.js, Jest-Cucumber |
| Ruby       | Cucumber                   |

### 优势与挑战

**主要优势**：沟通协作改善、需求清晰（减少返工）、聚焦业务价值、活文档、质量内建、可维护性强

**面临挑战**：学习曲线、文化变革（业务方参与承诺）、测试维护成本、工具开销

### 最佳实践
- **场景应是声明性的**：描述"做什么（What）"而非"怎么做（How）"，避免提及UI控件
- **保持场景独立**：每个场景可以独立运行
- **重用步骤定义**：减少代码重复
- **定期评审 Feature 文件**：与业务人员确保仍然准确反映需求

### 结论
BDD本质上是一种**围绕业务行为进行沟通和协作的软件开发范式**。它搭建了连接业务与技术的桥梁，其成功高度依赖于团队文化转变和所有角色的共同努力。
