# 领域设计

本文汇总领域设计相关方法论，包含：领域驱动设计（DDD）、命令查询职责分离（CQRS）。

---

## 一、领域驱动设计（DDD）

### 概述
DDD 并非具体的技术框架，而是一套旨在应对复杂软件系统设计的**思想、原则和实践模式**。核心目标是将软件焦点置于业务领域本身，通过精准的**领域模型**指导软件设计与实现。

**核心体系：战略设计 + 战术设计**

| 分类层级           | 核心目标                     | 关键概念                             | 关注范围                       |
| ------------------ | ---------------------------- | ------------------------------------ | ------------------------------ |
| **核心理念**       | 建立DDD基础思维模式          | 通用语言、模型驱动设计               | 整个开发过程的沟通与建模哲学   |
| **战略设计**       | 划分系统边界，管理宏观复杂性 | 限界上下文、子域、上下文映射图       | 系统级、架构级、团队协作       |
| **战术设计**       | 实现高质量的领域模型         | 实体、值对象、聚合、工厂、仓储、服务 | 单个限界上下文内部的模型细节   |
| **实践与生命周期** | 将DDD思想落地                | 事件风暴、知识消化、持续重构         | 探索、分析和演进领域模型的过程 |

### 第一部分：核心理念与基石

#### 1. 通用语言（Ubiquitous Language）
在项目所有参与者（领域专家、开发、测试、产品）中共享、无歧义、严格定义的语言，既用于口头交流，也体现在代码和文档中。

**目的**：消除沟通障碍；驱动模型（语言中的名词/动词直接映射到代码结构）；统一认知。

#### 2. 模型驱动设计（Model-Driven Design）
领域模型不是静态图表，而是软件设计的核心和骨架。**代码即设计**，代码结构忠实反映领域模型。

### 第二部分：战略设计

#### 1. 子域（Subdomain）— 问题空间
| 类型         | 说明                       | 策略                     |
| ------------ | -------------------------- | ------------------------ |
| **核心域**   | 企业核心竞争力和差异化所在 | 投入最优秀资源，自主研发 |
| **支撑子域** | 业务必需但非核心竞争力     | 自研，优先级低于核心域   |
| **通用子域** | 业界有成熟解决方案         | 购买或使用开源方案       |

#### 2. 限界上下文（Bounded Context）— 解决方案空间
圈定特定领域模型和通用语言的适用范围的逻辑边界。**微服务划分的最佳依据**。

避免模型混淆：同一词在不同上下文有不同含义（如"商品"在库存和销售上下文中关注点不同）。

#### 3. 上下文映射图（Context Map）——集成关系模式

| 模式                     | 说明                                             |
| ------------------------ | ------------------------------------------------ |
| 合作关系 (Partnership)   | 两个上下文紧密合作，共同演进                     |
| 共享内核 (Shared Kernel) | 共享部分模型代码，变更成本高                     |
| 客户-供应商              | 下游向上游提出需求，上游承担责任                 |
| 遵从者 (Conformist)      | 下游完全遵从上游模型                             |
| **防腐层 (ACL)**         | 下游创建翻译层保护自身不受上游变化冲击（最常用） |
| 开放主机服务 (OHS)       | 上游通过公开稳定协议（REST API）提供服务         |
| 发布语言                 | 通过公开数据交换格式通信（JSON Schema等）        |
| 分道扬镳                 | 两个上下文之间无集成关系                         |

### 第三部分：战术设计

#### 1. 实体（Entity）
有**唯一标识符（ID）**且状态随时间变化的领域对象。相等性由ID判断，非属性。

示例：`User`、`Order`

#### 2. 值对象（Value Object）
描述某属性的对象，**无ID**，通常**不可变**。相等性由所有属性值决定。

示例：`Address`、`Money`、`DateRange`

#### 3. 聚合（Aggregate）
一组相关领域对象的集群，通过**聚合根（Aggregate Root）**作为唯一入口。
- 聚合根负责验证和执行业务规则（保证不变性）
- 外部对象只能引用聚合根，不能直接访问内部对象
- 跨聚合引用只能通过ID

示例：`Order`（聚合根）包含 `OrderItem`（实体）和 `ShippingAddress`（值对象）

#### 4. 工厂（Factory）
封装创建复杂对象或聚合的逻辑，确保被创建对象处于合法初始状态。

#### 5. 仓储（Repository）
提供类似内存集合接口的持久化抽象层，**仅为聚合根提供存取服务**，解耦领域模型和数据层。

#### 6. 服务（Service）
当领域逻辑不适合放在任何实体或值对象中时使用，通常无状态。
- **领域服务**：跨多个聚合的核心业务逻辑
- **应用服务**：协调领域对象完成用例，是外部客户端的入口

### 第四部分：实践与生命周期

- **事件风暴（Event Storming）**：协作式工作坊，贴领域事件即时贴，梳理业务流程，快速建立通用语言
- **知识消化（Knowledge Crunching）**：开发者与领域专家持续深入协作，提炼完善领域模型
- **持续重构（Continuous Refactoring）**：随着对业务理解深入，不断重构代码以更好反映新认知

### 总结
- **战略设计**帮助我们看清森林，合理分解系统，管理团队和模块间协作
- **战术设计**指导我们在清晰边界内构建健壮、灵活的领域模型

---

## 二、命令查询职责分离（CQRS）

### 核心定义
将系统中**改变状态的操作（命令，Command）**与**读取状态的操作（查询，Query）**明确分离。

- **命令（Command）**：代表执行动作/改变状态的意图（如 `CreateUserCommand`），不返回值或只返回标识符
- **查询（Query）**：从系统获取数据，**绝不能**改变任何系统状态，返回数据（通常是DTO）

### 基于"分离程度"的分类

#### 逻辑分离（单一数据存储）
读写在代码层面分离，但操作同一数据库。
- 命令侧：丰富的领域模型（如DDD聚合），包含业务逻辑
- 查询侧：专门为读取优化的扁平化模型
- **优点**：实现简单，不引入数据同步复杂性；**缺点**：读写竞争同一数据库资源

#### 物理分离（多个数据存储）
使用不同的物理数据存储（多语言持久化）：
- 命令侧：关系型数据库（PostgreSQL等），保证事务和一致性，是"事实之源"
- 查询侧：按场景选择（全文搜索→Elasticsearch，文档→MongoDB，缓存→Redis，分析→ClickHouse）
- 数据同步：通过事件和消息队列（Kafka, RabbitMQ）异步更新（"投影"）
- **优点**：极致性能和伸缩性；**缺点**：引入最终一致性，架构复杂

### 基于"模型复杂度"的分类

| 类型                     | 命令模型                               | 查询模型                 | 适用场景                         |
| ------------------------ | -------------------------------------- | ------------------------ | -------------------------------- |
| **简单CQRS**             | 事务脚本或贫血领域模型                 | 简单DTO，ORM/SQL直接查询 | 业务不复杂但读写负载差异明显     |
| **任务驱动**             | 与UI任务对齐，每个命令对应用户操作意图 | 为特定视图/API端点定制   | 前后端协作，后端清晰理解用户行为 |
| **领域驱动（CQRS+DDD）** | DDD聚合作为核心，命令处理产生领域事件  | 无领域逻辑，只读取和展示 | 极复杂业务领域（最经典组合）     |

### 基于"与相关模式的组合"

#### CQRS + 事件溯源（Event Sourcing）— 黄金搭档
- 命令侧不存储当前状态，而是存储导致状态变化的一系列**不可变事件**
- 优势：完整审计日志；可重建任何历史时间点的状态；可基于同一事件流构建多种读取模型

#### CQRS + 微服务
- **服务内CQRS**：单个微服务内部采用CQRS组织代码和数据
- **服务间CQRS**：一个服务（如`OrderService`）专门处理命令，另一个（如`ReportingService`）订阅事件构建读取模型

### 适用场景与反模式

**适用**：
- 高性能高伸缩性需求（读写流量差异大）
- 复杂业务领域（写模型保证一致性，读模型按场景优化）
- 需要历史追溯和审计（CQRS+ES）
- 协作型应用（多用户同时操作同一数据）

**避免**：简单CRUD应用、业务领域简单、团队经验不足、强一致性需求无处不在

### 总结

| 分类维度   | 类型                   | 复杂度 |
| ---------- | ---------------------- | ------ |
| 分离程度   | 逻辑分离（单一数据库） | 低     |
| 分离程度   | 物理分离（不同数据库） | 高     |
| 模型复杂度 | 简单CQRS               | 低     |
| 模型复杂度 | 任务驱动               | 中     |
| 模型复杂度 | 领域驱动               | 高     |
| 模式组合   | CQRS+ES                | 极高   |
| 模式组合   | CQRS+微服务            | 中/高  |

CQRS不是银弹，从最简单的逻辑分离开始，逐步演进到更复杂的模式，通常是稳妥的策略。
