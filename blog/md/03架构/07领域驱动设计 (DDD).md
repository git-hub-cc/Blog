好的，遵照您的要求，这是一份对领域驱动设计（DDD）进行系统性分类的完整文档。

---

## **领域驱动设计 (Domain-Driven Design, DDD) 分类全解文档**

### **文档概述**

领域驱动设计（Domain-Driven Design, DDD）并非一种具体的技术框架，而是一套旨在应对复杂软件系统设计的**思想、原则和实践模式**。其核心目标是将软件的核心焦点置于业务领域本身，通过建立一个精准、一致且能反映业务本质的**领域模型（Domain Model）**，来指导软件的设计与实现，从而有效管理复杂性，确保软件能够精准地满足业务需求并随之演进。

本文档将DDD的完整体系划分为两大核心部分：**战略设计**与**战术设计**。此外，我们还会探讨支撑这两部分的基础理念以及将DDD付诸实践的生命周期方法。

### **分类概览图**

为了更直观地理解DDD的结构，我们可以用下表进行概览：

| 分类层级 | 核心目标 | 关键概念 | 关注范围 |
| :--- | :--- | :--- | :--- |
| **核心理念 (Foundation)** | 建立DDD的基础思维模式 | 通用语言 (Ubiquitous Language)<br>模型驱动设计 (Model-Driven Design) | 整个开发过程的沟通与建模哲学 |
| **战略设计 (Strategic Design)** | 划分系统边界，管理宏观复杂性 | 限界上下文 (Bounded Context)<br>子域 (Subdomain)<br>上下文映射图 (Context Map) | 系统级、架构级、团队协作 |
| **战术设计 (Tactic Design)** | 实现高质量的领域模型 | 实体 (Entity)<br>值对象 (Value Object)<br>聚合 (Aggregate)<br>工厂 (Factory)<br>仓储 (Repository)<br>服务 (Service) | 单个限界上下文内部的模型细节 |
| **实践与生命周期** | 将DDD思想落地的方法 | 事件风暴 (Event Storming)<br>知识消化 (Knowledge Crunching)<br>持续重构 (Continuous Refactoring) | 探索、分析和演进领域模型的过程 |

---

### **第一部分：核心理念与基石 (The Foundation)**

在深入战略和战术设计之前，必须理解支撑DDD的两个基石。

#### **1. 通用语言 (Ubiquitous Language)**

- **定义**：一套在项目团队（包括领域专家、开发人员、测试人员、产品经理等所有相关方）中共享的、无歧义的、严格定义的语言。这套语言既用于口头交流，也体现在代码、文档、数据库模式等所有产物中。
- **目的**：
    - **消除沟通障碍**：避免因术语理解不一导致的“翻译”成本和需求误解。
    - **驱动模型**：通用语言中的名词、动词和规则直接映射到领域模型中的对象、方法和约束。
    - **统一认知**：确保所有人对业务领域的理解保持一致。
- **示例**：在电商领域，“订单”在通用语言中被定义为“客户一次购买行为的凭证，包含商品列表、收货信息和支付状态”。那么代码中就会有`Order`类，其属性和方法也应反映这一定义。

#### **2. 模型驱动设计 (Model-Driven Design)**

- **定义**：强调领域模型不是一个仅供分析的静态图表，而是软件设计的核心和骨架。代码的结构、类和方法的设计都应忠实地反映领域模型。
- **目的**：
    - **代码即设计**：让代码本身成为领域知识的最终、最精确的表达。
    - **保持一致性**：确保软件实现与业务模型之间不脱节。当业务变化时，首先修改模型，然后驱动代码进行相应调整。

---

### **第二部分：战略设计 (Strategic Design)**

战略设计关注的是宏观层面，帮助我们分解复杂的系统，定义清晰的边界，并管理不同部分之间的关系。

#### **1. 子域 (Subdomain)**

- **定义**：整个业务领域（Domain）可以被划分为若干个更小的、有内在逻辑联系的问题域，即子域。
- **分类**：
    - **核心域 (Core Domain)**：业务成功的关键，是企业的核心竞争力和差异化所在。应投入最优秀的资源进行自主研发。例如，一个视频网站的“推荐算法”或一个金融公司的“风控引擎”。
    - **支撑子域 (Supporting Subdomain)**：对业务是必需的，但不是核心竞争力。通常比较特定，难以购买现成方案，需要自研，但优先级低于核心域。例如，电商平台的“报表系统”。
    - **通用子域 (Generic Subdomain)**：业界已经有成熟解决方案的问题域，非业务核心。应优先选择购买或使用开源方案，而不是自研。例如，“身份认证”、“短信通知服务”。

#### **2. 限界上下文 (Bounded Context)**

- **定义**：一个逻辑上的边界，用于圈定一个特定的领域模型和其通用语言的适用范围。在边界内，每个术语都有唯一、明确的含义。限界上下文是**解决方案空间**的概念，而子域是**问题空间**的概念。一个限界上下文通常对应一个子域。
- **目的**：
    - **避免模型混淆**：同一个词在不同上下文中可能有不同含义。例如，“商品”（Product）在“库存上下文”中关心的是SKU和数量，而在“销售上下文”中关心的是价格、描述和图片。
    - **保障团队自治**：每个限界上下文可以由一个独立的团队负责，他们可以在自己的边界内自由地演进模型，而不会干扰其他团队。
    - **微服务的划分依据**：限界上下文是划分微服务边界最理想的依据。

#### **3. 上下文映射图 (Context Map)**

- **定义**：描绘不同限界上下文之间集成关系的图谱。它清晰地定义了团队之间、系统模块之间的协作模式。
- **常见的集成模式分类**：
    - **合作关系 (Partnership)**：两个上下文（或团队）紧密合作，共同演进，一荣俱荣，一损俱损。
    - **共享内核 (Shared Kernel)**：两个上下文共享一部分模型代码（如jar包、代码库）。需要强有力的协调，变更成本高，需谨慎使用。
    - **客户-供应商 (Customer-Supplier)**：存在明确的上下游关系。下游是客户，可以向上游提出需求；上游是供应商，需要满足下游的需求并承担责任。
    - **遵从者 (Conformist)**：下游完全遵从上游的模型，不对其进行转换或挑战。适用于上游强大且稳定，或下游没有话语权的情况。
    - **防腐层 (Anticorruption Layer, ACL)**：在下游上下文中创建一个翻译层，将上游的模型转换成自己内部的模型。这是最常用、最稳健的防御性模式，能有效保护下游模型不受上游变化的冲击。
    - **开放主机服务 (Open Host Service, OHS)**：上游通过定义一套公开、稳定的协议（如REST API）来提供服务，供所有下游消费。
    - **发布语言 (Published Language)**：多个上下文之间通过一种公开、通用的数据交换格式（如JSON Schema, Avro）进行通信。
    - **分道扬镳 (Separate Ways)**：两个上下文之间没有集成关系。

---

### **第三部分：战术设计 (Tactic Design)**

战术设计关注的是微观层面，提供了在**单个限界上下文内部**构建高质量领域模型的具体模式和构建块。

#### **1. 实体 (Entity)**

- **定义**：具有**唯一标识符（ID）**并且其状态会随时间变化的领域对象。我们关心的是它的生命周期和身份，而不是其属性。
- **特点**：
    - 拥有全局唯一的ID。
    - 状态是可变的。
    - 其相等性判断依据是ID，而非属性。
- **示例**：`User`（用户ID唯一）、`Order`（订单ID唯一）。

#### **2. 值对象 (Value Object)**

- **定义**：用于描述事物某个方面或属性的对象，没有唯一标识符。其相等性由构成它的所有属性值决定。
- **特点**：
    - 无ID。
    - 通常是**不可变的（Immutable）**，任何修改都应返回一个新的值对象实例。
    - 相等性判断依据是所有属性的值。
- **示例**：`Address`（地址）、`Money`（金额，包含币种和数值）、`DateRange`（日期范围）。

#### **3. 聚合 (Aggregate)**

- **定义**：一组相关领域对象（实体和值对象）的集群，被视为一个数据修改的单元。聚合通过一个称为**聚合根（Aggregate Root）**的入口来管理内部所有对象。
- **目的**：
    - **保证业务规则（不变性）的一致性**：所有业务操作都必须通过聚合根进行，聚合根负责验证和执行规则，确保聚合内的数据在任何时候都处于有效状态。
    - **定义事务边界**：对数据库的每一次修改（事务）都应作用于一个完整的聚合。
- **规则**：
    - **聚合根是唯一入口**：外部对象只能引用聚合根，不能直接引用聚合内部的其他对象。
    - **聚合内引用**：聚合内部的对象可以相互引用。
    - **跨聚合引用**：只能通过ID引用其他聚合的聚合根。
- **示例**：一个“订单”聚合，`Order`是聚合根，内部包含`OrderItem`（订单项）实体列表和`ShippingAddress`（收货地址）值对象。要修改订单项数量，必须调用`Order.changeItemQuantity()`方法，而不能直接操作`OrderItem`。

#### **4. 工厂 (Factory)**

- **定义**：负责创建复杂对象或聚合的类或方法。它封装了创建逻辑，确保被创建的对象处于一个合法的、一致的初始状态。
- **目的**：将对象的创建职责从客户端代码中分离出来，简化客户端逻辑，并强化业务约束。
- **示例**：`OrderFactory.createOrder(customer, items)`，这个工厂方法内部可能包含检查库存、计算总价等复杂逻辑。

#### **5. 仓储 (Repository)**

- **定义**：一个提供类似内存集合接口的持久化抽象层。它封装了数据访问的细节（如SQL、ORM框架），使得领域层可以不用关心数据是如何存储和检索的。
- **职责**：
    - 仅为**聚合根**提供存取服务。
    - 提供基于业务场景的查询方法（如 `findOrderByCustomerId`），而不是通用的技术性查询（如 `findBySQL`）。
    - 模拟集合操作，如 `add`, `remove`, `findById`。
- **目的**：解耦领域模型和数据持久化层。

#### **6. 服务 (Service)**

- **定义**：当某项领域逻辑不适合放在任何一个实体或值对象中时，可以将其封装在服务中。服务通常是无状态的。
- **分类**：
    - **领域服务 (Domain Service)**：封装核心的、跨多个聚合的业务逻辑。例如，一个`FundTransferService`（转账服务）可能需要协调两个`Account`（账户）聚合。
    - **应用服务 (Application Service)**：负责协调领域对象来完成一个用例（Use Case）。它是外部客户端（如API控制器）的直接入口，负责事务管理、权限校验、日志记录等。它不包含业务规则，只是一个“调度者”。

---

### **第四部分：实践与生命周期 (Lifecycle & Practices)**

DDD不仅是模式，更是一种持续的活动。

#### **1. 事件风暴 (Event Storming)**

- **定义**：一种协作式的、以工作坊形式进行的快速领域探索方法。通过让领域专家和开发团队一起在墙上贴满代表**领域事件（Domain Event）**的即时贴，来梳理业务流程、发现命令、识别聚合和限界上下文。
- **作用**：快速建立通用语言，可视化业务全貌，是启动DDD项目的绝佳实践。

#### **2. 知识消化 (Knowledge Crunching)**

- **定义**：开发人员与领域专家之间持续、深入的协作过程。通过不断地沟通、实验、画图和编码，双方共同提炼和完善领域模型。

#### **3. 持续重构 (Continuous Refactoring)**

- **定义**：领域模型不是一成不变的。随着对业务理解的深入，团队需要不断地重构代码，以更好地反映新的认知（“重构以获得更深的洞见”）。这种重构不仅仅是代码优化，更是模型本身的演进。

### **总结**

领域驱动设计通过其**战略**和**战术**两大分类，为我们提供了一套从宏观架构到微观实现的完整设计武器库。

- **战略设计**帮助我们看清森林，合理地分解系统，管理团队和模块间的协作。
- **战术设计**则指导我们种好每一棵树，在清晰的边界内构建出健壮、灵活且能精准表达业务的领域模型。

最终，成功实施DDD的关键在于拥抱其**核心理念**：始终以**通用语言**为沟通桥梁，坚持**模型驱动设计**，并将其融入到整个软件的**生命周期**中。