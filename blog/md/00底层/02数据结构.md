#### **第一章：基本概念**

在深入具体的数据结构之前，首先需要理解两种基本的组织方式：逻辑结构和物理结构。

*   **逻辑结构 (Logical Structure)**
    描述数据元素之间的逻辑关系，与它们在计算机中的存储位置无关。它关注的是数据“看起来”是什么样的。逻辑结构主要分为线性结构和非线性结构两大类。

*   **物理结构/存储结构 (Physical Structure)**
    描述数据在计算机内存中的实际存储方式。它关注的是数据“实际上”是如何存放的。主要的物理结构有顺序存储、链式存储、索引存储和散列存储。

*   **顺序存储结构 (Sequential Storage Structure)**
    将逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中。通常借助数组实现。优点是支持随机访问，缺点是插入和删除操作效率较低。

*   **链式存储结构 (Linked Storage Structure)**
    数据元素的存储单元可以任意分布，通过指针或引用来表示元素间的逻辑关系。优点是插入删除灵活，缺点是无法随机访问，且需要额外空间存储指针。

*   **索引存储结构 (Indexed Storage Structure)**
    在存储数据元素的同时，建立一个额外的索引表。索引表中的每一项称为索引项，用于快速定位数据。这种方式可以显著提高检索速度。

*   **散列存储结构/哈希存储 (Hashed Storage Structure)**
    根据元素的关键字通过散列函数直接计算出其存储地址。这种结构提供了极快的平均查找、插入和删除速度，是实现哈希表的基础。

---

#### **第二章：线性数据结构 (Linear Data Structures)**

线性数据结构是最基础的一类结构，其特点是数据元素之间存在“一对一”的线性关系。

##### **2.1 基础线性表**

*   **数组 (Array)**
    一种最基础的线性结构，由相同类型的元素组成，并存储在连续的内存空间中。通过索引可以实现O(1)复杂度的快速随机访问。

*   **链表 (Linked List)**
    由一系列节点组成，每个节点包含数据和指向下一个节点的指针。它允许在O(1)时间内进行高效的插入和删除，但访问元素需要O(n)时间。

*   **单向链表 (Singly Linked List)**
    链表的最基本形式。每个节点只包含一个指向其直接后继节点的指针。遍历只能单向进行，从头节点到尾节点。

*   **双向链表 (Doubly Linked List)**
    每个节点包含两个指针，一个指向前驱节点，一个指向后继节点。这使得双向遍历成为可能，并简化了某些删除操作。

*   **循环链表 (Circular Linked List)**
    一种特殊的链表，其中最后一个节点的指针不是指向null，而是指向头节点，形成一个环。适用于需要循环处理数据的场景。

*   **静态链表 (Static Linked List)**
    使用数组来模拟链表的行为。数组的每个元素代表一个节点，通过索引（游标）代替指针来连接节点。适用于不支持指针的编程语言。

##### **2.2 受限线性表**

这类结构是线性表的变体，对元素的插入和删除操作位置进行了限制。

*   **栈 (Stack)**
    一种后进先出（LIFO）的数据结构。所有操作（如压入push、弹出pop）都在表的同一端（栈顶）进行。常用于函数调用、表达式求值等。

*   **队列 (Queue)**
    一种先进先出（FIFO）的数据结构。数据从一端（队尾）进入，从另一端（队头）离开。常用于任务调度、消息传递和广度优先搜索。

*   **双端队列 (Deque - Double-Ended Queue)**
    一种允许在两端进行插入和删除操作的队列。它结合了栈和队列的特性，提供了更大的灵活性，可以作为栈或队列使用。

*   **优先队列 (Priority Queue)**
    一种特殊的队列，其中每个元素都关联一个优先级。出队时，优先级最高的元素最先被移除。通常使用堆来实现。

##### **2.3 线性表的特殊应用**

*   **稀疏数组 (Sparse Array)**
    当一个数组中大部分元素为同一默认值（通常是0）时，为了节省空间，可以使用稀疏数组。它只存储非默认值的元素及其位置信息。

---

#### **第三章：哈希数据结构 (Hash-based Data Structures)**

哈希结构通过哈希函数将键（Key）映射到存储位置，以实现快速访问。

*   **哈希表 / 散列表 (Hash Table / Hash Map)**
    一种实现了关联数组抽象数据类型的结构。它通过哈希函数计算键的索引，实现平均O(1)的查找、插入和删除。核心在于处理哈希冲突。

*   **哈希集合 (Hash Set)**
    基于哈希表实现的集合。它利用哈希表的键来存储唯一的元素，可以快速检查一个元素是否存在于集合中，以及进行插入和删除。

*   **分布式哈希表 (Distributed Hash Table - DHT)**
    一种用于去中心化系统的哈希表。键值对分布在网络中的多个节点上，每个节点只负责一小部分数据，共同组成一个巨大的哈希表。

*   **布隆过滤器 (Bloom Filter)**
    一种空间效率极高的概率型数据结构。用于判断一个元素是否可能在一个集合中。它有一定误判率（可能将不在的元素判断为存在），但绝不会漏判。

*   **布谷鸟哈希 (Cuckoo Hashing)**
    一种解决哈希冲突的开放寻址策略。它使用多个哈希函数，当发生冲突时，会像布谷鸟一样“踢走”旧元素，为新元素腾出位置。

*   **跳表 (Skip List)**
    一种通过多层链表实现的有序数据结构。它以概率方式构建索引层，实现平均O(log n)的查找、插入和删除，性能媲美平衡树但实现更简单。

---

#### **第四章：树形数据结构 (Tree Data Structures)**

树形结构是一种非线性结构，用于表示具有层级关系的数据。每个节点最多有一个父节点。

##### **4.1 基本树形结构**

*   **树 (Tree)**
    由n（n>=0）个节点组成的有限集合。有一个特殊的根节点，其余节点可分为多个互不相交的子集，每个子集本身也是一棵树，称为根的子树。

*   **二叉树 (Binary Tree)**
    树的最常见形式，每个节点最多有两个子节点，通常称为“左子节点”和“右子节点”。是许多高级树结构的基础。

*   **满二叉树 (Full Binary Tree)**
    一棵二叉树，如果其中每个节点要么是叶子节点，要么都有两个子节点，则称之为满二叉树。结构非常规整。

*   **完全二叉树 (Complete Binary Tree)**
    除了最后一层外，其他各层节点数都达到最大，且最后一层的节点都连续集中在左侧。堆通常用完全二叉树来实现。

*   **完美二叉树 (Perfect Binary Tree)**
    一种特殊的满二叉树，所有叶子节点都在同一层。它的节点总数为 `2^h - 1`，其中 `h` 是树的高度。

##### **4.2 搜索树**

这类树结构主要用于高效地搜索、插入和删除数据。

*   **二叉搜索树 (Binary Search Tree - BST)**
    一种有序的二叉树。对于任意节点，其左子树中所有节点的值都小于该节点，右子树中所有节点的值都大于该节点。

*   **AVL树 (Adelson-Velsky and Landis' Tree)**
    最早的自平衡二叉搜索树。它要求任何节点的两个子树的高度差最多为1。通过旋转操作来维持平衡，保证了操作的对数时间复杂度。

*   **红黑树 (Red-Black Tree)**
    一种应用广泛的自平衡二叉搜索树。通过为节点分配红或黑两种颜色并遵循特定规则来维持平衡，确保最长路径不超过最短路径的两倍。

*   **伸展树 (Splay Tree)**
    一种自优化的二叉搜索树。它会在每次访问一个节点后，通过一系列旋转操作将其移动到树的根部。这使得频繁访问的元素能够被更快地再次访问。

*   **替罪羊树 (Scapegoat Tree)**
    一种不完全平衡的二叉搜索树。它不要求严格平衡，而是设定一个阈值。当某个子树变得“过于不平衡”时，会直接重建成一棵完全平衡的子树。

*   **树堆 (Treap)**
    一种结合了二叉搜索树和堆特性的数据结构。每个节点除了有键（Key）之外，还有一个随机生成的优先级（Priority），同时满足BST和堆的性质。

##### **4.3 B-系列树 (B-Family Trees)**

这类树通常具有较高的扇出（一个节点有多个子节点），主要用于数据库和文件系统，以减少磁盘I/O次数。

*   **B树 (B-Tree)**
    一种为磁盘或其他直接存取辅助设备而设计的平衡搜索树。它使节点可以拥有多个子节点，从而降低树的高度，减少了数据查找时的磁盘读取次数。

*   **B+树 (B+ Tree)**
    B树的一种变体。其特点是所有数据都存储在叶子节点中，且叶子节点之间通过指针相连形成一个有序链表。非常适合范围查询。

*   **B\*树 (B\* Tree)**
    B+树的另一种变体。它在B+树的基础上，要求非根节点至少填充2/3，而不是B+树的1/2。这提高了空间利用率，但插入删除更复杂。

*   **2-3树 (2-3 Tree)**
    B树的一种特例，每个内部节点可以有2个或3个子节点。所有叶子节点都在同一层级，是一种简单高效的平衡搜索树。

*   **2-3-4树 (2-3-4 Tree)**
    与2-3树类似，是B树的另一种特例，内部节点可有2、3或4个子节点。红黑树可以看作是2-3-4树的一种等价实现。

##### **4.4 堆 (Heap)**

堆是一种特殊的基于树的结构，通常是完全二叉树，并满足堆属性。

*   **二叉堆 (Binary Heap)**
    用完全二叉树实现的堆。根据堆属性分为最大堆（父节点值大于等于子节点）和最小堆（父节点值小于等于子节点）。常用于实现优先队列。

*   **二项堆 (Binomial Heap)**
    由一组二项树组成的堆。它的主要优点是合并两个堆的操作非常高效，时间复杂度为O(log n)。

*   **斐波那契堆 (Fibonacci Heap)**
    由一组遵循最小堆有序的树构成。它支持比二项堆更快的“减小关键字”操作，在某些图算法（如Dijkstra）中有理论上的性能优势。

*   **配对堆 (Pairing Heap)**
    一种实现简单、实践中性能优异的多路树堆。它在摊还分析下具有良好的性能，是斐波나契堆的一种更易于实现的替代方案。

*   **弱堆 (Weak Heap)**
    一种二叉堆的变体，它放宽了堆的属性要求，从而在某些操作上可能比标准二叉堆更快。

##### **4.5 字典树/前缀树 (Trie / Prefix Tree)**

这类树专门用于高效地存储和检索字符串集合，常用于字典查询和自动补全。

*   **标准字典树 (Trie / Prefix Tree)**
    一种多叉树，每个节点代表一个字符，从根到某节点的路径构成一个字符串。非常适合前缀匹配和词频统计，但空间开销较大。

*   **基数树 / 压缩字典树 (Radix Tree / Patricia Trie)**
    标准Trie的优化版。它将路径上只有一个子节点的节点进行合并，形成一个字符串标签。这极大地减少了节点数量和内存占用。

*   **三叉搜索树 (Ternary Search Tree - TST)**
    一种结合了二叉搜索树和字典树特性的结构。每个节点有三个孩子（小于、等于、大于），在空间效率上优于标准Trie，比哈希表更灵活。

##### **4.6 空间数据结构树 (Spatial Data Structure Trees)**

这类树用于索引多维空间中的数据，在地理信息系统（GIS）、计算机图形学和机器人技术中非常重要。

*   **四叉树 (Quadtree)**
    用于索引二维空间数据。它将一个平面区域递归地划分为四个象限。常用于图像处理、地图索引和碰撞检测。

*   **八叉树 (Octree)**
    四叉树向三维空间的扩展。它将一个立方体空间递归地划分为八个卦限。广泛应用于3D建模、物理模拟和点云数据处理。

*   **k-d树 (k-dimensional Tree)**
    用于组织k维空间中的点。在树的每一层，它沿着一个特定的维度对数据进行分割。适用于最近邻搜索等范围查询。

*   **R树 (R-Tree)**
    一种用于索引多维空间对象（如矩形、多边形）的平衡树。它将邻近的对象组合成最小边界矩形（MBR），并存储在父节点中。

*   **R+树 (R+ Tree)**
    R树的变体，通过不允许节点的边界矩形重叠来解决性能问题。当插入导致重叠时，它会分割对象而不是矩形。

*   **R\*树 (R\* Tree)**
    R树的另一种高级变体。它在节点分裂时，采用更复杂的启发式策略，如最小化重叠、周长和面积，以获得更好的查询性能。

*   **球树 (Ball Tree)**
    一种用于在高维空间中进行快速最近邻搜索的结构。它将数据点划分到嵌套的超球面（“球”）中，比k-d树在某些高维场景下更有效。

##### **4.7 其他专用树结构**

这些树为解决特定计算问题（如范围查询、数据校验）提供了高效的解决方案。

*   **线段树 (Segment Tree)**
    一种基于二叉树的结构，用于高效处理数组上的区间查询（如求和、最大/最小值）。每个节点代表一个区间，支持在O(log n)时间内进行查询和更新。

*   **树状数组 / 芬威克树 (Fenwick Tree / Binary Indexed Tree - BIT)**
    一种精巧的数据结构，用于高效计算序列的前缀和。它可以在O(log n)时间内完成单点更新和区间和查询，实现比线段树更简单，常数更小。

*   **区间树 (Interval Tree)**
    专门用于存储一维区间，并快速查找与给定区间或点重叠的所有区间。在计算几何和日程管理等领域有重要应用。

*   **默克尔树 / 哈希树 (Merkle Tree)**
    一种哈希二叉树，其叶节点是数据块的哈希值，非叶节点是其子节点哈希值的组合哈希。用于高效、安全地验证大型数据集的完整性，是区块链的核心技术之一。

---

#### **第五章：图形数据结构 (Graph Data Structures)**

图是一种非线性结构，由顶点（Vertices）和连接顶点的边（Edges）组成，用于表示对象间的“多对多”关系。

##### **5.1 基本概念与表示法**

*   **图 (Graph)**
    由顶点集合V和边集合E组成的结构，记为G=(V, E)。用于模拟网络、社交关系、路线图等复杂系统。

*   **邻接矩阵 (Adjacency Matrix)**
    使用一个V x V的二维数组来表示图。如果顶点i和j之间有边，则`matrix[i][j]`为1（或权重），否则为0。适合稠密图，判断连通性快。

*   **邻接表 (Adjacency List)**
    使用一个数组或哈希表，每个顶点的条目都链接一个包含其所有邻居的链表。节省空间，是稀疏图最常用的表示法。

*   **关联矩阵 (Incidence Matrix)**
    使用一个V x E的矩阵表示。如果顶点v是边e的一个端点，则`matrix[v][e]`为1，否则为0。主要用于图论的理论研究。

##### **5.2 图的类型**

*   **无向图 (Undirected Graph)**
    图中的边没有方向。如果顶点A和B之间有边，则可以从A到B，也可以从B到A。社交网络中的好友关系是典型例子。

*   **有向图 (Directed Graph / Digraph)**
    图中的边具有方向。如果存在从A到B的边，不一定存在从B到A的边。网页链接、任务依赖关系是典型例子。

*   **加权图 (Weighted Graph)**
    图中的每条边都关联一个数值（权重或成本）。权重可以代表距离、时间、费用等。常用于最短路径问题。

*   **无权图 (Unweighted Graph)**
    加权图的特例，所有边的权重都视为相同（通常为1）。关注的是连通性而非路径成本。

*   **有向无环图 (Directed Acyclic Graph - DAG)**
    一个没有有向环路（Cycle）的有向图。常用于表示具有依赖关系的任务，如项目调度、编译器中的依赖分析。

*   **多重图 (Multigraph)**
    允许在两个顶点之间存在多条边的图。例如，在交通网络中，两个城市间可能有多条不同的公路。

*   **超图 (Hypergraph)**

    图的泛化，其中一条边可以连接任意数量的顶点，而不仅仅是两个。用于表示更复杂的关系，如数据库中的协作关系。

---

#### **第六章：字符串专用数据结构 (Specialized String Data Structures)**

除了Trie之外，还有一些为高级字符串处理（如全文搜索、生物信息学）而生的强大结构。

*   **后缀树 (Suffix Tree)**
    一个包含字符串所有后缀的压缩Trie。它能在线性时间内构建，并支持极速的子串查找、最长公共子串等多种复杂操作。

*   - **后缀数组 (Suffix Array)**
      一个按字典序排序的所有字符串后缀的起始位置数组。功能与后缀树类似，但空间占用更小，更易于构建。常与LCP数组配合使用。

*   **最长公共前缀数组 (LCP Array)**
    与后缀数组配合使用，存储后缀数组中相邻两个后缀的最长公共前缀（LCP）的长度。它能加速许多基于后缀数组的算法。

*   **Aho-Corasick自动机**
    一种基于Trie的有限状态机。它可以在一段文本中同时查找多个模式串（关键字），效率极高。常用于敏感词过滤、病毒特征码匹配等场景。

#### **第七章：抽象数据类型 (Abstract Data Types - ADTs)**

ADT定义了数据的逻辑行为和可执行的操作，而不关心其具体实现。许多数据结构都是为了实现某种ADT。

*   **列表 (List ADT)**
    定义了一个有序的元素序列。基本操作包括添加元素、删除元素、访问指定位置的元素以及获取列表长度。可以用数组或链表等结构实现。

*   **集合 (Set ADT)**
    定义了一个包含不重复元素的无序集合。核心操作是添加元素、删除元素以及检查元素是否存在（成员资格测试）。可以用哈希表或平衡树实现。

*   **映射 / 字典 (Map / Dictionary ADT)**
    定义了一个键值对（Key-Value）的集合，每个键都是唯一的。主要操作包括插入键值对、根据键删除和查找值。可以用哈希表或搜索树实现。

*   **不相交集合 / 并查集 (Disjoint-Set Union - DSU)**
    一种处理不相交集合的合并与查询问题的数据结构。支持“查找”（Find）和“合并”（Union）两种操作，常用于判断图的连通性或Kruskal算法。

---

#### **第八章：并发数据结构 (Concurrent Data Structures)**

在多线程编程中，为保证数据安全和程序正确性，需要使用专为并发访问设计的线程安全数据结构。

*   **无锁数据结构 (Lock-Free Data Structure)**
    允许多个线程在不使用互斥锁的情况下并发访问数据。通常依赖原子操作（如CAS）来保证数据一致性，以提高系统吞吐量。

*   **免等待数据结构 (Wait-Free Data Structure)**
    无锁数据结构的更强形式。它保证任何线程都能在有限的步骤内完成其操作，不受其他线程速度或暂停的影响，杜绝了线程饥饿。

*   **并发哈希表 (Concurrent Hash Map)**
    线程安全的哈希表实现。通常采用分段锁或更精细的无锁技术，允许多个线程同时进行读写操作，提供了高并发性能。

*   **并发队列 (Concurrent Queue)**
    线程安全的队列。是生产者-消费者模型中的关键组件，有多种实现，如基于锁的阻塞队列或基于CAS的无锁队列。

*   **写时复制列表 (Copy-On-Write List)**
    一种实现并发访问的策略。读取操作无需加锁，直接访问现有数据。写入操作时，会复制一份数据副本进行修改，再原子性地替换掉旧数据。适用于读多写少的场景。

*   **阻塞队列 (Blocking Queue)**
    一种特殊的并发队列。当队列为空时，获取元素的操作会被阻塞直到有元素可用；当队列满时，插入元素的操作会被阻塞直到有空间可用。

---

#### **第九章：特定领域数据结构 (Domain-Specific Data Structures)**

这些数据结构是为解决特定领域的问题而设计和优化的。

##### **9.1 计算几何**

*   **维诺图 / 泰森多边形 (Voronoi Diagram)**
    在平面上，对于一组点，将平面划分为多个区域，使得每个区域内的任意位置都离该区域的控制点最近。用于解决最近点问题。

*   **德劳内三角剖分 (Delaunay Triangulation)**
    一组点的三角剖分，其特点是没有任何点在任何三角形的外接圆内部。与维诺图对偶，常用于网格生成和地形建模。

*   **翼边表示 (Winged-Edge Representation)**
    一种经典的表示三维多面体网格的边界表示法。它为每条边存储其两个端点、两个相邻面以及环绕该边的四条边，用于描述拓扑关系。

*   **半边数据结构 (Half-Edge Data Structure)**
    一种更现代和灵活的网格表示法。它将每条边拆分为两条有向的半边，极大地简化了对网格的遍历和局部修改操作。

##### **9.2 信息检索与数据库**

*   **倒排索引 (Inverted Index)**
    搜索引擎的核心数据结构。它存储了从词（Term）到包含该词的文档列表的映射。通过索引，可以极快地响应关键词查询。

*   **位图索引 (Bitmap Index)**
    一种特殊的数据库索引，它使用位数组（Bitmap）来记录特定列值与行的对应关系。对于基数（不同值的数量）较低的列，查询效率极高。

##### **9.3 生物信息学**

*   **德布鲁因图 (De Bruijn Graph)**
    在基因组学中，用于从大量短DNA片段（Reads）中重组完整基因序列的有向图。图的节点是k-mers（长度为k的子串），边表示它们的重叠关系。

##### **9.4 图像处理**

*   **积分图 (Summed-Area Table / Integral Image)**
    允许快速、高效地计算一个图像中任意矩形区域像素之和的数据结构。预计算后，任何矩形区域的和都只需四次数组访问。

---

#### **第十章：概率数据结构 (Probabilistic Data Structures)**

这类结构通过牺牲一定的准确性（允许小概率错误）来换取极高的空间效率和时间效率。

*   **Count-Min Sketch**
    用于估算数据流中元素频率的概率结构。它使用多个哈希函数将元素映射到一个二维数组中，查询时返回对应位置的最小值作为估算频率。

*   **HyperLogLog**
    一种用于基数估计的概率算法。它能以极小的内存消耗（通常只需几KB）来估算一个巨大集合中不同元素的数量，误差在可接受范围内。

*   **布隆过滤器 (Bloom Filter)** - (已在第一部分提及，此处归类于概率结构)
    一种空间效率极高的概率型数据结构。用于判断一个元素是否可能在一个集合中。它有一定误判率（可能将不在的元素判断为存在），但绝不会漏判。
