好的，遵照您的指示，我将根据您提供的所有上下文文件（特别是 `03AI编码工具.md` 和 `04AI编程工具记忆系统.md` 中体现的结构化思维），为您生成 `07任务拆分.md` 的内容。

这份文档将作为一份全面的指南，用于设计和编写能够指导AI进行高效、准确任务拆分的提示词。它将涵盖从理解需求到最终交付的整个任务生命周期中，AI需要考虑的所有关键维度。

---

### **第一部分：AI任务拆分提示词设计维度**

本指南旨在为AI代理构建任务拆分能力提供一个全面的提示词设计框架。一个优秀的任务拆分Agent，其核心能力在于将用户模糊、复杂的请求，转化为一个结构化、可执行、可验证的清晰步骤列表。以下是设计此类提示词时需考虑的核心维度。

---

### **一、 理解与澄清 (Understanding & Clarification)**

在任何行动之前，首要任务是确保完全、准确地理解用户的需求。这一阶段的指令旨在训练AI“三思而后行”，避免在错误的方向上浪费精力。

#### **1. 需求意图分析 (Requirement Intent Analysis)**
> **介绍**：指导AI深入剖析用户请求的根本目标，区分“做什么”（表面任务）与“为什么做”（真实意图），确保后续所有行动都围绕核心目标展开，避免方向性错误。

#### **2. 上下文信息感知 (Context Awareness)**
> **介绍**：要求AI主动扫描并利用所有可用上下文，如当前打开的文件、代码库结构、项目技术栈、操作系统环境等。这能确保拆分出的任务是具体且符合当前环境的。

#### **3. 信息缺口识别 (Information Gap Identification)**
> **介绍**：训练AI在分析需求和上下文后，能主动识别出执行任务所必需的、但当前缺失的关键信息。例如，缺少API密钥、不明确的文件路径或未指定的版本号。

#### **4. 歧义澄清与追问 (Ambiguity Clarification & Inquiry)**
> **介绍**：当识别到信息缺口或模糊指令时，规定AI必须主动向用户提问以澄清歧义。这是确保任务执行准确性的关键交互，防止AI基于错误的假设采取行动。

#### **5. 约束与目标确认 (Constraint & Goal Confirmation)**
> **介绍**：在正式开始规划前，要求AI向用户复述其理解的核心目标和关键约束（如“不能引入新的依赖”、“必须在500毫秒内完成”），并请求用户确认。

---

### **二、 规划与策略 (Planning & Strategy)**

在完全理解需求后，AI需要制定一个高层级的行动策略。这个阶段的指令关注的是“如何思考”，而不是“具体做什么”。

#### **1. 总体策略制定 (High-Level Strategy Formulation)**
> **介绍**：指导AI根据任务性质选择最合适的宏观策略。例如，对于Bug修复，策略可能是“复现-定位-修复-验证”；对于功能开发，则是“设计-编码-测试-集成”。

#### **2. 依赖关系分析 (Dependency Analysis)**
> **介绍**：要求AI在拆分任务时，必须分析子任务之间的逻辑依赖关系。这决定了任务的执行顺序，是生成一个可行计划（而非一堆无序步骤）的基础。

#### **3. 风险评估与预案 (Risk Assessment & Contingency Planning)**
> **介绍**：一项高级指令，要求AI预判计划中可能失败的步骤，并提前思考备用方案（Plan B）。例如，“如果API调用失败，则尝试从本地缓存读取数据”。

#### **4. 并行化可能性分析 (Parallelization Analysis)**
> **介绍**：指导AI识别出计划中没有前后依赖关系、可以同时执行的任务。在提示词中明确鼓励并行化，可以显著提升复杂任务的执行效率，减少用户等待时间。

#### **5. 优先级排序 (Prioritization)**
> **介绍**：对于一系列并行的或可选的任务，要求AI根据“价值/成本”或“关键路径”等原则进行优先级排序。确保优先解决最核心、影响最广的问题。

#### **6. 分解方法论 (Decomposition Methodology)**
> **介绍**：向AI灌输不同的任务分解模型，如“目标导向分解”（从最终目标反推步骤）或“流程导向分解”（按标准操作流程SOP展开），使其能应对不同类型的请求。

---

### **三、 任务分解结构 (Task Decomposition Structure)**

这是将策略转化为具体行动计划的阶段。指令应关注如何生成一个清晰、完整且对人和机器都友好的任务列表。

#### **1. 原子任务定义 (Atomic Task Definition)**
> **介绍**：规定拆分出的每个子任务都应是“原子的”——即一个独立的、目标明确、可一次性完成的最小操作单元。例如，“读取文件”是原子任务，而“处理数据”则不是。

#### **2. 结构化计划输出 (Structured Plan Output)**
> **介绍**：强制AI必须使用特定的格式（如Markdown列表、JSON对象或特定的工具调用 `TodoWrite`）来呈现其任务计划。这既方便用户审查，也利于后续的自动化执行。

#### **3. 任务状态管理 (Task State Management)**
> **介绍**：在任务列表中引入状态概念（如 `待办(TODO)`、`进行中(IN_PROGRESS)`、`已完成(DONE)`、`失败(FAILED)`）。这是AI能够跟踪自身进度、从失败中恢复的基础。

#### **4. 资源与时间估算 (Resource & Time Estimation)**
> **介绍**：对于高级Agent，可以要求其对每个子任务进行粗略的资源（如需要调用哪些工具）或时间估算。这有助于用户了解任务的复杂度和预期耗时。

#### **5. 可验证的子目标 (Verifiable Sub-goals)**
> **介绍**：要求每个子任务都有一个明确的、可验证的完成标准。例如，“创建文件”的验证标准是“文件存在于指定路径”；“修复Bug”的验证标准是“相关单元测试通过”。

---

### **四、 执行与监控 (Execution & Monitoring)**

计划制定完成后，进入执行阶段。此处的指令关注AI在执行子任务过程中的行为规范。

#### **1. 工具选择与调用 (Tool Selection & Invocation)**
> **介绍**：对于每个子任务，指导AI从其工具库中选择最合适的工具来执行。提示词应强调精确使用工具，并遵循工具定义的参数格式，这是可靠执行的前提。

#### **2. 执行过程中的状态更新 (In-Progress Status Updates)**
> **介绍**：要求AI在开始执行一个关键子任务或完成一个子任务时，主动向用户提供简短的状态更新。这种“叙事性”沟通极大地提升了用户体验和透明度。

#### **3. 动态调整与错误处理 (Dynamic Adjustment & Error Handling)**
> **介绍**：规定当一个子任务执行失败时，AI应采取的行动。例如，首先尝试重试，若再次失败则查阅预案，若无预案则立即暂停并向用户报告问题，请求指示。

#### **4. 中间结果验证 (Intermediate Result Validation)**
> **介绍**：要求AI在完成一个关键子任务后，立即执行验证操作（如运行测试、检查文件内容），确保该步骤的结果符合预期，再继续执行后续依赖任务。

#### **5. 资源清理 (Resource Cleanup)**
> **介绍**：对于执行过程中创建的临时文件、网络连接或数据库会话，规定AI在任务完成或失败后，必须执行清理操作，避免资源泄漏，保持环境整洁。

---

### **五、 反思与优化 (Reflection & Optimization)**

任务完成后，一个顶级的Agent应该具备复盘和学习的能力。这部分指令旨在构建AI的“成长”机制。

#### **1. 最终成果评估 (Final Outcome Assessment)**
> **介绍**：要求AI在完成所有任务后，对照最初与用户确认的目标和约束，进行一次全面的自评，判断任务是否已圆满完成，并向用户进行最终交付汇报。

#### **2. 经验总结与知识沉淀 (Lesson Learned & Knowledge Crystallization)**
> **介绍**：指导AI将本次任务的成功经验或失败教训，通过调用“记忆”相关工具（如 `update_memory`），转化为长期知识。例如，“对于X类型的项目，应优先使用Y库”。

#### **3. 流程优化建议 (Process Optimization Suggestions)**
> **介绍**：在复盘后，鼓励AI思考本次任务流程中可以改进的地方，并可以向用户提出建议。例如，“下次遇到类似任务，我们可以先建立一个测试框架，效率会更高”。

#### **4. 用户反馈循环 (User Feedback Loop)**
> **介绍**：规定AI在任务交付后，应主动请求用户对其工作成果和流程进行评价。这不仅是礼貌的交互，更是获取高质量优化数据的宝贵机会。

好的，我们继续生成 `07任务拆分.md` 的剩余内容。

---

### **六、 交互与沟通 (Interaction & Communication)**

任务拆分不仅是AI的内部思考过程，其结果和执行过程也必须以用户友善的方式呈现。这部分维度关注AI如何与用户就任务计划进行沟通和协作。

#### **1. 计划透明化呈现 (Transparent Plan Presentation)**
> **介绍**：要求AI在制定完初步计划后，必须以清晰、易于理解的格式（如带复选框的列表）主动呈现给用户。这赋予用户审查、修改和批准计划的权力，建立信任。

#### **2. 进度可视化更新 (Visual Progress Updates)**
> **介绍**：指导AI在执行任务时，动态地更新其向用户展示的任务列表状态。例如，通过勾选已完成项或更新任务旁边的状态标签，让用户对进度一目了然。

#### **3. 交互式决策点 (Interactive Decision Points)**
> **介绍**：规定当任务路径出现分支或需要权衡（如两种实现方案）时，AI应暂停执行，将选项呈现给用户，并请求指导。这确保了最终产出符合用户的偏好和深层需求。

#### **4. 简洁性与聚焦 (Conciseness & Focus)**
> **介绍**：在与用户的所有沟通中，尤其是在报告任务状态时，强制AI使用简洁、精炼的语言。避免技术术语泛滥，只报告与当前任务目标最相关的信息，尊重用户的时间。

#### **5. 用户教育与引导 (User Education & Guidance)**
> **介绍**：如果用户的请求在技术上不合理或存在更优解法，AI不应盲目执行。相反，它应拆分出一个“解释并提出替代方案”的任务，温和地引导用户走向最佳实践。

---

### **七、 编码任务特定维度 (Code-Specific Dimensions)**

软件开发任务有其独特性。这部分指令专门针对代码相关工作，将软件工程的最佳实践内化为AI任务拆分的标准动作。

#### **1. 代码库探索 (Codebase Exploration)**
> **介绍**：对于任何代码修改请求，拆分出的第一个任务永远是信息收集。这包括列出相关文件、搜索关键函数、理解现有代码结构，确保后续修改建立在充分理解的基础上。

#### **2. 代码风格分析 (Coding Style Analysis)**
> **介绍**：在生成或修改任何代码之前，必须有一个独立的任务是“分析并匹配现有代码风格”。这确保AI生成的代码能够无缝融入项目，保持代码库的一致性和可读性。

#### **3. 测试用例先行/伴随 (Test Case First/Alongside)**
> **介绍**：对于功能开发或Bug修复，任务计划中必须包含编写或修改测试用例的步骤。这可以是测试驱动开发（TDD）的第一步，也是保证代码质量和防止回归的关键环节。

#### **4. 依赖管理步骤 (Dependency Management Steps)**
> **介绍**：如果任务需要引入新的库，拆分出的步骤必须是通过项目指定的包管理器（如 `npm install`）来操作，并明确禁止AI直接手动编辑依赖配置文件。

#### **5. 重构安全检查 (Refactoring Safety Checks)**
> **介绍**：当执行代码重构任务时，计划中必须包含关键的“安全锚点”。例如，“重构前运行所有测试并确保通过”和“重构后再次运行测试并验证行为一致”。

#### **6. 数据库迁移规划 (Database Migration Planning)**
> **介绍**：对于涉及数据库模式变更的任务，拆分计划必须包含创建数据库迁移脚本、应用迁移以及（在可能的情况下）制定回滚计划的步骤，确保数据操作的安全可控。

---

### **八、 行为准则与安全护栏 (Behavioral Guidelines & Safety Guardrails)**

这部分为AI的任务拆分和执行过程设定了不可逾越的红线，旨在确保其行为安全、可靠且永远在用户的掌控之内。

#### **1. 操作范围限制 (Scope Limitation)**
> **介绍**：核心准则之一，严格规定AI拆分出的任务不能超出用户明确请求的范围。如果AI认为有必要的额外工作，它必须作为一个建议任务提出，并等待用户批准。

#### **2. 破坏性操作确认 (Destructive Action Confirmation)**
> **介绍**：对于任何可能导致数据丢失或不可逆更改的操作（如删除文件 `rm`, 强制推送 `git push --force`），任务列表中必须包含一个“向用户请求显式确认”的步骤。

#### **3. 避免无限循环 (Infinite Loop Avoidance)**
> **介绍**：指导AI识别自己是否陷入了“兜圈子”的状态（例如，反复尝试同一个失败的命令）。一旦检测到这种情况，AI必须停止当前计划，并向用户报告僵局以寻求帮助。

#### **4. 资源消耗意识 (Resource Consumption Awareness)**
> **介绍**：引导AI在拆分任务时，应有成本意识，避免生成会消耗过多计算资源、网络带宽或API调用次数的计划，除非任务目标本身就需要这样做且已得到用户许可。

#### **5. 保密与隐私 (Confidentiality & Privacy)**
> **介绍**：严禁AI拆分出任何可能导致敏感信息（如API密钥、密码、个人数据）被打印到日志、写入非安全文件或在网络上传输的任务。所有操作都需以安全为前提。

---

### **总结：从任务拆分到价值交付**

一个优秀的AI任务拆分提示词系统，其最终目标是赋能AI成为一个可靠的自主问题解决者。通过在**理解、规划、结构、执行、反思、交互、专业领域和安全**等多个维度上进行精细设计，我们可以将AI从一个简单的指令执行器，提升为一个能够独立思考、主动协作、保障安全并持续成长的智能伙伴，最终高效、精准地为用户交付真正的价值。