### **1. 组件化拆分 (Component Breakdown)**

为了构建这个高度交互的WebTop界面，我们需要将UI拆分为一系列可管理、可复用和独立的组件。

*   **`AuthLayout` & `DesktopLayout`:**
    *   **功能:** 顶层布局组件。`AuthLayout` 用于包裹登录/注册页面。`DesktopLayout` 用于在用户登录后，渲染整个桌面环境，并负责获取和设置桌面壁纸。

*   **`LoginPage` & `RegisterPage`:**
    *   **功能:** 分别实现用户登录和注册的表单页面。

*   **`DesktopCanvas`:**
    *   **功能:** 代表桌面区域本身。渲染所有根级别的 `DesktopItem`，处理桌面右键菜单事件。

*   **`DesktopItem`:**
    *   **功能:** 显示单个桌面项目（应用或文件夹）的图标和名称。处理单击（选中）、双击（打开）、拖拽和右键菜单事件。

*   **`Window`:**
    *   **功能:** 通用的、可拖拽、可缩放的窗口组件。这是项目的核心交互组件之一。
    *   **内部结构:** `WindowTitleBar` (含标题和控件) 和 `WindowContent` (渲染`<iframe>`或文件夹内容)。
    *   **样式:** 将严格按照更新后的“Win10风格”UI指南实现。

*   **`WindowManager` (逻辑组件/Provider):**
    *   **功能:** 一个不渲染UI的逻辑管理器。负责管理所有窗口的全局状态（z-index, 位置, 大小, 最小化状态等）。

*   **`Taskbar` & `TaskbarItem`:**
    *   **功能:** 位于屏幕底部的任务栏，显示开始菜单按钮和已打开应用的图标。样式遵循Win10风格。

*   **`StartMenu`:**
    *   **功能:** 点击开始按钮后弹出的菜单，用于快速启动应用。

*   **`ContextMenu`:**
    *   **功能:** 右键点击时出现的上下文菜单，内容根据点击目标动态生成。

*   **`Dialog` (基础组件):**
    *   **功能:** 封装的模态对话框，用于“创建新应用”等操作。

---

### **2. 状态管理策略 (State Management Strategy)**

使用 **React Context** 结合 `useReducer` 或轻量级状态库 (如 **Zustand**) 来管理全局状态。

*   **全局状态 (Global State):**
    1.  **`session`**: 存储用户数据和认证JWT。如果为null，则表示用户未登录，应用应重定向到登录页。
    2.  **`desktopItems`**: 从 `GET /api/v1/desktop-items` 获取的所有应用和文件夹对象的数组。
    3.  **`openWindows`**: 记录当前所有打开窗口状态的数组。
    4.  **`userSettings`**: 存储用户的个性化设置，如 `wallpaperUrl`。

*   **局部状态 (Local State):** 使用 `useState` 进行管理，例如`ContextMenu`的可见性和位置、表单输入框的当前值等。

---

### **3. 数据交互逻辑 (Data Fetching Logic)**

以 **“获取并渲染用户的桌面项目”** 这个核心流程为例：

1.  **组件:** 在顶层的 `DesktopLayout` 组件中执行此逻辑。

2.  **触发时机:** 组件首次挂载时，使用 `useEffect` hook。

3.  **执行流程:**

    ```javascript
    // 在 DesktopLayout.jsx 中
    // 假设使用Zustand store
    const { session, setDesktopItems, setUserSettings } = useAppStore();

    useEffect(() => {
      // 确保用户已登录
      if (!session) return;

      const fetchInitialData = async () => {
        try {
          // 假设 apiClient 已配置好，会自动附加Authorization头
          const [itemsResponse, settingsResponse] = await Promise.all([
            apiClient.get('/api/v1/desktop-items'),
            apiClient.get('/api/v1/user/settings')
          ]);
          
          // 更新全局状态
          setDesktopItems(itemsResponse.data.items);
          setUserSettings(settingsResponse.data);
          
        } catch (error) {
          console.error("Failed to fetch initial desktop data:", error);
          // 可以在此显示全局错误通知
        }
      };

      fetchInitialData();
    }, [session]); // 依赖session，确保登录后执行

    // ... 根据状态进行渲染 ...
    ```

**后续交互:** 当用户拖动一个桌面图标到新位置时，`DesktopItem` 组件会触发一个回调，该回调会乐观地更新UI状态，并异步调用 `PATCH /api/v1/desktop-items/{itemId}` API，请求体中包含新的 `position`，将更改持久化到后端。本版本**不会**在窗口移动或关闭时持久化窗口的状态。
