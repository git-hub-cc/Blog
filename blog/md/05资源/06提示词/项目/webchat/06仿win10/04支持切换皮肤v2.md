好的，收到V2.0蓝图。作为全栈开发专家，我将严格遵循蓝图中的所有要求，对V1.0代码库进行升级，以实现动态主题系统。

我将输出所有新增和修改的文件。由于代码量较大，我将分 **3** 次输出。

*   **第一部分:** 核心逻辑和数据结构变更。包括 `storage.service.ts`, `types/index.ts`, `stores/ui.ts`，以及新增的主题配置文件和CSS样式文件。
*   **第二部分:** 新增的视图组件。包括 `views/ThemeSelectionScreen.vue` 和 `views/DesktopShell.vue`。
*   **第三部分:** 应用入口的重构和最终整合。包括 `App.vue` 和 `main.ts` 的修改。

---

### **项目结构 V2.0 (概览)**

请注意新增的 `views` 和 `themes` 目录，以及 `assets` 下的新文件。

```
webos-desktop/
└── frontend/
    └── src/
        ├── App.vue  (Modified)
        ├── main.ts  (Modified)
        ├── assets/
        │   ├── icons/
        │   ├── themes/ (New)
        │   │   ├── win10.css
        │   │   └── win8.css
        │   ├── previews/ (New)
        │   │   ├── win10-preview.jpg
        │   │   └── win8-preview.jpg
        │   ├── win10-bg.jpg
        │   └── win8-bg.jpg (New)
        ├── components/
        │   ├── ... (Unchanged)
        ├── services/
        │   └── storage.service.ts (Modified)
        ├── stores/
        │   ├── ui.ts (Modified)
        │   ├── ... (Unchanged)
        ├── themes/ (New)
        │   └── index.ts
        ├── types/
        │   └── index.ts (Modified)
        └── views/ (New)
            ├── DesktopShell.vue
            └── ThemeSelectionScreen.vue
```
---

### **第一部分: 核心逻辑与数据结构**

#### **frontend/src/services/storage.service.ts (Modified)**
```typescript
// A simple service to interact with localStorage
import type { WebAppShortcut } from '../types';

const SHORTCUTS_KEY = 'webos-desktop-shortcuts';
const THEME_KEY = 'webos-desktop-theme'; // New key for storing the selected theme

export const storageService = {
  getShortcuts(): WebAppShortcut[] {
    const data = localStorage.getItem(SHORTCUTS_KEY);
    return data ? JSON.parse(data) : [];
  },

  saveShortcuts(shortcuts: WebAppShortcut[]): void {
    localStorage.setItem(SHORTCUTS_KEY, JSON.stringify(shortcuts));
  },

  // --- New Methods for Theme Management ---
  getTheme(): string | null {
    return localStorage.getItem(THEME_KEY);
  },

  saveTheme(themeId: string): void {
    localStorage.setItem(THEME_KEY, themeId);
  },
};
```

#### **frontend/src/types/index.ts (Modified)**
```typescript
// Data models defined as per the blueprint

export interface WebAppShortcut {
  id: string;
  name: string;
  url: string;
  iconUrl: string;
  position: { x: number; y: number };
}

export interface OpenWindow {
  id: string;
  shortcutId: string;
  title: string;
  iconUrl: string;
  position: { x: number; y: number };
  size: { width: number; height: number };
  zIndex: number;
  state: 'normal' | 'maximized' | 'minimized';
}

// --- New Interface for Theme Definition ---
export interface Theme {
  id: 'win10' | 'win8'; // Using string literals for type safety
  name: string;
  wallpaperUrl: string;
  previewImageUrl: string;
}
```

#### **frontend/src/stores/ui.ts (Modified)**
```typescript
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { storageService } from '../services/storage.service';
import { themes, type Theme } from '../themes'; // Import new theme config

export const useUiStore = defineStore('ui', () => {
  // --- Existing State ---
  const isStartMenuOpen = ref(false);

  // --- New State for Theming ---
  const activeThemeId = ref<string | null>(null);

  // --- Computed Property to get the full theme object ---
  const activeTheme = computed<Theme | undefined>(() => {
    return themes.find(t => t.id === activeThemeId.value);
  });

  // --- Existing Actions ---
  function toggleStartMenu() {
    isStartMenuOpen.value = !isStartMenuOpen.value;
  }
  
  function closeStartMenu() {
    isStartMenuOpen.value = false;
  }

  // --- New Actions for Theme Management ---
  function loadTheme() {
    const savedThemeId = storageService.getTheme();
    if (savedThemeId && themes.some(t => t.id === savedThemeId)) {
      activeThemeId.value = savedThemeId;
    }
  }

  function setTheme(themeId: string) {
    storageService.saveTheme(themeId);
    activeThemeId.value = themeId;
  }

  return { 
    isStartMenuOpen, 
    toggleStartMenu, 
    closeStartMenu,
    activeTheme,
    loadTheme,
    setTheme
  };
});
```

#### **frontend/src/themes/index.ts (New File)**
```typescript
import type { Theme } from '../types';
import Win10Wallpaper from '../assets/win10-bg.jpg';
import Win8Wallpaper from '../assets/win8-bg.jpg';
import Win10Preview from '../assets/previews/win10-preview.jpg';
import Win8Preview from '../assets/previews/win8-preview.jpg';

export const themes: Theme[] = [
  { 
    id: 'win10', 
    name: 'Windows 10', 
    wallpaperUrl: Win10Wallpaper,
    previewImageUrl: Win10Preview
  },
  { 
    id: 'win8', 
    name: 'Windows 8', 
    wallpaperUrl: Win8Wallpaper,
    previewImageUrl: Win8Preview
  }
];
```

#### **frontend/src/assets/themes/win10.css (New File)**
```css
/* Windows 10 Theme Specific Styles */
.theme-win10 .taskbar {
    background-color: rgba(32, 32, 32, 0.8);
    backdrop-filter: blur(10px);
}

.theme-win10 .start-menu {
    background-color: rgba(32, 32, 32, 0.9);
    backdrop-filter: blur(12px);
}

.theme-win10 .desktop-window-titlebar {
    background-color: #202020;
}

.theme-win10 .taskbar-item-active-indicator {
    background-color: #0078D6;
}

.theme-win10 .taskbar-item-minimized-indicator {
    background-color: #7a7a7a;
}
```

#### **frontend/src/assets/themes/win8.css (New File)**
```css
/* Windows 8 Theme Specific Styles */
.theme-win8 .taskbar {
    background-color: #1a1a1a; /* Solid, darker color */
}

.theme-win8 .start-menu {
    background-color: #1f1f1f; /* A slightly different solid dark */
}

/* Make windows look more flat */
.theme-win8 .desktop-window {
    border-radius: 0;
    border: 1px solid #555;
}

.theme-win8 .desktop-window-titlebar {
    background-color: #2d2d2d;
}

.theme-win8 .taskbar-item {
    background-color: transparent;
}

.theme-win8 .taskbar-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.theme-win8 .taskbar-item-active {
    background-color: rgba(255, 255, 255, 0.15);
}

.theme-win8 .taskbar-item-active-indicator {
    background-color: #7b0099; /* A purple accent */
}

.theme-win8 .taskbar-item-minimized-indicator {
    background-color: #888;
}
```

#### **New Assets**

*   **`frontend/src/assets/win8-bg.jpg`:** Please add a suitable Windows 8 style wallpaper here.
*   **`frontend/src/assets/previews/win10-preview.jpg`:** Please add a preview image/screenshot of the Win10 theme.
*   **`frontend/src/assets/previews/win8-preview.jpg`:** Please add a preview image/screenshot of the Win8 theme.


好的，继续第二部分。

这一部分将包含实现主题化UI所需的核心视图组件和对现有组件的必要重构。我将提供所有新增的视图文件，并更新那些需要移除硬编码样式以支持动态主题的组件。

---

### **第二部分: UI重构与新增视图**

#### **frontend/src/components/Taskbar/Taskbar.vue (Modified)**
*重构说明: 移除了硬编码的背景颜色 (`bg-win-dark/80`)，替换为语义化的 CSS 类 `taskbar`，其样式将由主题CSS文件控制。*
```vue
<script setup lang="ts">
import StartButton from './StartButton.vue';
import TaskbarItem from './TaskbarItem.vue';
import { useWindowsStore } from '../../stores/windows';

const windowsStore = useWindowsStore();
</script>

<template>
  <div class="taskbar absolute bottom-0 left-0 right-0 h-10 flex items-center z-200">
    <StartButton />
    <div class="flex items-center space-x-1 ml-2">
      <TaskbarItem 
        v-for="window in windowsStore.windows" 
        :key="window.id" 
        :window-instance="window" 
      />
    </div>
  </div>
</template>
```

#### **frontend/src/components/Taskbar/TaskbarItem.vue (Modified)**
*重构说明: `bg-win-blue` 和 `bg-gray-400` 等硬编码颜色类已被移除。现在，指示器 `div` 会根据窗口状态动态应用 `taskbar-item-active-indicator` 或 `taskbar-item-minimized-indicator` 类，这些类的具体颜色由加载的主题CSS定义。父按钮也获得了可被主题样式化的 `taskbar-item` 和 `taskbar-item--active` 类。*
```vue
<script setup lang="ts">
import { computed } from 'vue';
import type { OpenWindow } from '../../types';
import { useWindowsStore } from '../../stores/windows';

const props = defineProps<{
  windowInstance: OpenWindow;
}>();

const windowsStore = useWindowsStore();

const isActive = computed(() => windowsStore.activeWindowId === props.windowInstance.id && props.windowInstance.state !== 'minimized');

const handleClick = () => {
    if (props.windowInstance.state === 'minimized') {
        windowsStore.restoreWindow(props.windowInstance.id);
    } else {
        if (isActive.value) {
            windowsStore.minimizeWindow(props.windowInstance.id);
        } else {
            windowsStore.focusWindow(props.windowInstance.id);
        }
    }
};
</script>

<template>
  <button 
    @click="handleClick"
    class="taskbar-item flex items-center h-full px-3 text-white text-sm bg-white/10 hover:bg-white/20 relative"
    :class="{ 'taskbar-item--active bg-white/20': isActive }"
  >
    <img :src="windowInstance.iconUrl" class="w-4 h-4 mr-2" />
    <span>{{ windowInstance.title }}</span>
    <div 
        v-if="isActive || windowInstance.state === 'minimized'"
        class="absolute bottom-0 left-1 right-1 h-0.5"
        :class="{
          'taskbar-item-active-indicator': isActive,
          'taskbar-item-minimized-indicator': windowInstance.state === 'minimized' && !isActive
        }"
    ></div>
  </button>
</template>
```

#### **frontend/src/components/StartMenu/StartMenu.vue (Modified)**
*重构说明: 移除了硬编码的背景颜色 (`bg-win-dark/90`)，替换为语义化的 CSS 类 `start-menu`。*
```vue
<script setup lang="ts">
import { useShortcutsStore } from '../../stores/shortcuts';
import StartMenuItem from './StartMenuItem.vue';

const shortcutsStore = useShortcutsStore();

const handleClick = (e: MouseEvent) => {
    e.stopPropagation();
}
</script>

<template>
  <div 
    @click="handleClick"
    class="start-menu absolute bottom-10 left-0 w-80 h-96 z-200 p-2 flex flex-col"
  >
    <h2 class="text-white text-lg font-semibold px-2 mb-2">Applications</h2>
    <div class="flex-grow overflow-y-auto">
        <StartMenuItem 
            v-for="shortcut in shortcutsStore.shortcuts"
            :key="shortcut.id"
            :shortcut="shortcut"
        />
    </div>
  </div>
</template>
```

#### **frontend/src/components/Desktop/DesktopWindow.vue (Modified)**
*重构说明: 所有 `win-*` 颜色类都被移除。组件现在使用如 `desktop-window`、`desktop-window-titlebar` 等通用类，并通过 `desktop-window--active` 类来表示激活状态。这使得主题CSS可以完全控制窗口的外观。*
```vue
<script setup lang="ts">
import { ref, computed, watch } from 'vue';
import { useDraggable } from '@vueuse/core';
import type { OpenWindow } from '../../types';
import { useWindowsStore } from '../../stores/windows';

// Icons
import MinimizeIcon from '../../assets/icons/minimize.svg';
import MaximizeIcon from '../../assets/icons/maximize.svg';
import RestoreIcon from '../../assets/icons/restore.svg';
import CloseIcon from '../../assets/icons/close.svg';

const props = defineProps<{
  windowInstance: OpenWindow;
}>();

const windowsStore = useWindowsStore();
const el = ref<HTMLElement | null>(null);
const titleBar = ref<HTMLElement | null>(null);

const windowData = ref({
    x: props.windowInstance.position.x,
    y: props.windowInstance.position.y,
    width: props.windowInstance.size.width,
    height: props.windowInstance.size.height,
});

// Window Dragging
useDraggable(el, {
  handle: titleBar,
  initialValue: { x: windowData.value.x, y: windowData.value.y },
  onMove: (pos) => {
      if (props.windowInstance.state === 'maximized') return;
      windowData.value.x = pos.x;
      windowData.value.y = pos.y;
  },
  onEnd: () => {
      windowsStore.moveWindow(props.windowInstance.id, { x: windowData.value.x, y: windowData.value.y });
  }
});

// Window Resizing
const resizer = ref<HTMLElement | null>(null);
useDraggable(resizer, {
    onMove: (pos, event) => {
        if (props.windowInstance.state === 'maximized') return;
        windowData.value.width += event.movementX;
        windowData.value.height += event.movementY;
    },
    onEnd: () => {
        windowsStore.resizeWindow(props.windowInstance.id, { width: windowData.value.width, height: windowData.value.height });
    }
});

watch(() => props.windowInstance, (newVal) => {
    windowData.value = {
        x: newVal.position.x,
        y: newVal.position.y,
        width: newVal.size.width,
        height: newVal.size.height,
    };
}, { deep: true });

const windowClasses = computed(() => {
    if (props.windowInstance.state === 'minimized') {
        return 'hidden';
    }
    if (props.windowInstance.state === 'maximized') {
        return 'w-full h-[calc(100%-40px)] top-0 left-0';
    }
    return '';
});

const windowStyle = computed(() => {
    if (props.windowInstance.state === 'maximized') {
        return { zIndex: props.windowInstance.zIndex };
    }
    return {
        left: `${windowData.value.x}px`,
        top: `${windowData.value.y}px`,
        width: `${windowData.value.width}px`,
        height: `${windowData.value.height}px`,
        zIndex: props.windowInstance.zIndex,
    };
});

const isActive = computed(() => windowsStore.activeWindowId === props.windowInstance.id);

const onFocus = () => {
  windowsStore.focusWindow(props.windowInstance.id);
};
</script>

<template>
  <div
    ref="el"
    class="desktop-window fixed flex flex-col border shadow-2xl rounded-sm"
    :class="[windowClasses, { 'desktop-window--active': isActive }]"
    :style="windowStyle"
    @mousedown="onFocus"
  >
    <!-- Title Bar -->
    <div ref="titleBar" class="desktop-window-titlebar flex items-center justify-between h-8 px-2 cursor-move">
      <div class="flex items-center">
        <img :src="windowInstance.iconUrl" class="w-4 h-4 mr-2" />
        <span class="text-white text-sm">{{ windowInstance.title }}</span>
      </div>
      <div class="flex items-center space-x-1">
        <button @click="windowsStore.minimizeWindow(windowInstance.id)" class="w-8 h-6 flex justify-center items-center hover:bg-gray-500"><img :src="MinimizeIcon" class="w-3 h-3 invert" /></button>
        <button @click="windowsStore.maximizeWindow(windowInstance.id)" class="w-8 h-6 flex justify-center items-center hover:bg-gray-500">
            <img v-if="windowInstance.state !== 'maximized'" :src="MaximizeIcon" class="w-3 h-3 invert" />
            <img v-else :src="RestoreIcon" class="w-3 h-3 invert" />
        </button>
        <button @click="windowsStore.closeWindow(windowInstance.id)" class="w-8 h-6 flex justify-center items-center hover:bg-red-500"><img :src="CloseIcon" class="w-3 h-3 invert" /></button>
      </div>
    </div>
    
    <!-- Content -->
    <div class="flex-grow bg-white">
      <iframe :src="windowInstance.url" class="w-full h-full border-none"></iframe>
    </div>

    <!-- Resizer -->
    <div 
      ref="resizer" 
      v-if="windowInstance.state !== 'maximized'"
      class="absolute bottom-0 right-0 w-3 h-3 cursor-nwse-resize"
    ></div>
  </div>
</template>
```

#### **frontend/src/views/ThemeSelectionScreen.vue (New File)**
```vue
<script setup lang="ts">
import { useUiStore } from '../stores/ui';
import { themes } from '../themes';

const uiStore = useUiStore();

const selectTheme = (themeId: 'win10' | 'win8') => {
  uiStore.setTheme(themeId);
};
</script>

<template>
  <div class="w-screen h-screen bg-gray-900 flex flex-col items-center justify-center p-8">
    <h1 class="text-5xl font-thin text-white mb-4">Choose Your World</h1>
    <p class="text-gray-400 mb-12">Select an experience to begin.</p>
    
    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
      <div
        v-for="theme in themes"
        :key="theme.id"
        @click="selectTheme(theme.id)"
        class="theme-card relative w-80 h-48 bg-gray-800 rounded-lg overflow-hidden cursor-pointer transition-transform transform hover:scale-105"
      >
        <img :src="theme.previewImageUrl" :alt="theme.name" class="w-full h-full object-cover opacity-75" />
        <div class="absolute inset-0 bg-gradient-to-t from-black/70 to-transparent"></div>
        <h2 class="absolute bottom-4 left-4 text-2xl font-semibold text-white">{{ theme.name }}</h2>
      </div>
    </div>
  </div>
</template>
```

#### **frontend/src/views/DesktopShell.vue (New File)**
```vue
<script setup lang="ts">
import { computed } from 'vue';
import { useWindowsStore } from '../stores/windows';
import { useUiStore } from '../stores/ui';
import { useShortcutsStore } from '../stores/shortcuts';
import DesktopIcon from '../components/Desktop/DesktopIcon.vue';
import DesktopWindow from '../components/Desktop/DesktopWindow.vue';
import Taskbar from '../components/Taskbar/Taskbar.vue';
import StartMenu from '../components/StartMenu/StartMenu.vue';

const windowsStore = useWindowsStore();
const uiStore = useUiStore();
const shortcutsStore = useShortcutsStore();

function handleDesktopClick() {
  uiStore.closeStartMenu();
}

const wallpaperStyle = computed(() => ({
  backgroundImage: `url('${uiStore.activeTheme?.wallpaperUrl}')`
}));
</script>

<template>
  <div 
    class="relative w-screen h-screen overflow-hidden bg-cover bg-center transition-all duration-500"
    :style="wallpaperStyle"
    @click="handleDesktopClick"
  >
    <!-- Desktop Icons -->
    <DesktopIcon 
      v-for="shortcut in shortcutsStore.shortcuts" 
      :key="shortcut.id" 
      :shortcut="shortcut"
    />

    <!-- Open Windows -->
    <DesktopWindow 
      v-for="window in windowsStore.windows" 
      :key="window.id" 
      :window-instance="window"
    />

    <!-- Start Menu -->
    <StartMenu v-if="uiStore.isStartMenuOpen" />

    <!-- Taskbar -->
    <Taskbar />
  </div>
</template>
```


好的，这是最后一部分。

这一部分将完成应用入口的重构，将所有逻辑整合在一起，实现蓝图中的 "引导" 阶段，并导入所有主题样式。

---

### **第三部分: 应用入口与最终整合**

#### **frontend/src/main.ts (Modified)**
*修改说明: 按照蓝图要求，导入了所有主题的CSS文件。这样可以确保无论哪个主题被激活，对应的样式规则都已加载到文档中，可以通过根元素上的 `theme-*` 类来激活。*
```typescript
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import './assets/tailwind.css' // Import Tailwind CSS base
import App from './App.vue'

// Import all theme-specific styles as per the blueprint
import './assets/themes/win10.css';
import './assets/themes/win8.css';

const app = createApp(App)
const pinia = createPinia()

app.use(pinia)
app.mount('#app')
```

#### **frontend/src/App.vue (Modified)**
*修改说明: 这个文件是V2.0架构的核心。它不再直接渲染桌面，而是扮演一个"引导程序"或"调度器"的角色。*
1.  **逻辑变更:**
    *   在 `onMounted` 生命周期钩子中，调用 `uiStore.loadTheme()` 来检查 `localStorage` 中是否有已保存的主题。
    *   `activeTheme` 计算属性会根据 `uiStore` 的状态变化。
    *   模板使用 `v-if="activeTheme"` 来决定是渲染桌面 (`DesktopShell`) 还是主题选择界面 (`ThemeSelectionScreen`)。
2.  **动态Class绑定:**
    *   当 `activeTheme` 存在时，一个包含动态主题ID的 `div` 会包裹 `DesktopShell`。例如，如果选择了"Windows 10"，它会渲染成 `<div class="theme-win10">...</div>`。这就是激活主题样式的关键。
3.  **过渡效果:**
    *   `<Transition>` 组件被用来包裹动态切换的视图，实现了蓝图中建议的平滑淡入淡出效果，提升了用户体验。
```vue
<script setup lang="ts">
import { onMounted, computed } from 'vue';
import { useUiStore } from './stores/ui';
import ThemeSelectionScreen from './views/ThemeSelectionScreen.vue';
import DesktopShell from './views/DesktopShell.vue';

const uiStore = useUiStore();

// On application start, attempt to load the theme from localStorage
onMounted(() => {
  uiStore.loadTheme();
});

const activeTheme = computed(() => uiStore.activeTheme);
</script>

<template>
  <div id="webo-desktop-root" class="w-full h-full">
    <Transition name="fade" mode="out-in">
      <!-- If a theme is selected, render the desktop environment -->
      <div v-if="activeTheme" :key="activeTheme.id" :class="`theme-${activeTheme.id}`" class="w-full h-full">
        <DesktopShell />
      </div>
      <!-- Otherwise, show the theme selection screen -->
      <ThemeSelectionScreen v-else key="selection" />
    </Transition>
  </div>
</template>

<style>
/* Styles for the fade transition between theme selection and desktop */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.5s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

---

### **总结**

至此，所有根据V2.0蓝图需要修改和新增的文件都已提供。

**回顾一下变更:**
1.  **数据层:** `storage.service` 和 `ui.store` 现在能够管理和持久化主题状态。`types` 和 `themes` 目录定义了主题的数据结构。
2.  **样式层:** 新增了 `assets/themes` 目录，存放特定于主题的CSS文件，并通过 `main.ts` 导入。
3.  **视图层:**
    *   `App.vue` 被重构成一个引导程序，根据是否存在已选主题，在 `ThemeSelectionScreen` 和 `DesktopShell` 之间切换。
    *   `DesktopShell.vue` 现在包含了之前在 `App.vue` 中的所有桌面组件，并能动态应用壁纸。
    *   `ThemeSelectionScreen.vue` 是一个全新的界面，用于首次访问时让用户选择主题。
4.  **组件层:** 核心UI组件 (Taskbar, Window, StartMenu等) 的硬编码样式已被移除，替换为通用的CSS类，使其能够被主题CSS覆盖。

现在，当您运行更新后的前端应用时：
*   **首次访问:** 会看到 "Choose Your World" 界面。
*   **选择主题后:** 界面会平滑过渡到所选主题的桌面环境，该选择会被保存在 `localStorage`。
*   **再次访问:** 应用将直接加载上次选择的主题桌面，跳过选择步骤。

V2.0的动态主题系统已完全实现。

