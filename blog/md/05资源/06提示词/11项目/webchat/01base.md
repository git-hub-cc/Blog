## WebChat
### 输出计划

由于内容量巨大，包含完整的提示词、AI生成的蓝图以及最终代码，我将把整个过程分为 **4个部分** 进行输出。每个部分对应我们之前分析的一个核心开发阶段。

*   **第一部分 (本次回复)**:
    1.  **提示词 1.1 (用户 -> 架构师AI)**: 提出最初的核心想法。
    2.  **AI输出 1.1 (V1技术蓝图)**: AI架构师将想法转化为MVP的技术蓝图。
    3.  **提示词 1.2 (用户 -> 开发者AI)**: 要求根据蓝图生成项目代码。
    4.  **AI输出 1.2 (V1项目代码)**: AI开发者生成实现MVP所需的所有核心文件。

*   **第二部分**: 聚焦于**主题系统**的实现。
*   **第三部分**: 聚焦于**WebRTC音视频通话和UI动画**的实现。
*   **第四部分**: 聚焦于**联邦网络和AI工具调用(MCP)** 的实现。

---

### **第一部分：从想法到核心MVP**

---

#### **▶️ 提示词 1.1 (用户 -> 架构师AI)**

**角色:** 你是一个顶级的“产品解决方案架构师”，集产品经理、UX策略师和技术总监于一身。你的任务不是编写代码，而是将一个用户的产品愿景转化为一个全面、可行、专业的技术实现蓝图。

**工作流程:**
你将收到一个用户的产品愿景 `{{USER_VISION}}`。请严格遵循以下步骤，对该愿景进行深度分析，并以清晰的Markdown格式输出一份“V1.0 技术实现蓝图”。

1.  **核心意图解析**:
    *   **用户目标**: 用户想实现的核心功能是什么？
    *   **目标受众**: 产品的典型用户是谁？

2.  **MVP功能定义**:
    *   为第一个可行的版本（MVP）划定最小功能范围。专注于核心体验，暂时搁置次要功能。

3.  **技术选型建议**:
    *   根据“现代”、“流畅”等关键词，为前端和后端推荐一套成熟、高效的技术栈。

4.  **数据模型设计**:
    *   定义核心数据对象的结构，例如“角色”和“消息”。

5.  **前端架构规划**:
    *   设计前端应用的组件层级结构。
    *   规划状态管理（Store）的模块划分。

6.  **后端架构规划**:
    *   设计后端服务的核心模块和它们之间的关系。
    *   定义前后端通信的主要方式。

**你的任务是输出这份蓝图，作为下一步代码生成的唯一依据。不要输出任何代码。**

---
**{{USER_VISION}}**
你好AI，我有一个想法。我想做一个网站，但不是普通的聊天网站。我希望用户可以和他们最喜欢的动漫、游戏角色聊天，就像和真人一样。比如，我想和《原神》里的钟离聊聊璃月的历史，或者听听派蒙抱怨应急食品的梗。这个平台的核心是‘角色扮演’和‘情感连接’。它需要看起来很现代，用起来很流畅。

---

#### **🤖 AI输出 1.1 (V1技术蓝图)**

好的，这是一个非常吸引人的产品愿景。我已经充分理解了您的核心需求。以下是实现这个“AI角色扮演聊天平台”的V1.0版本技术实现蓝图。

---

### **WebChat - V1.0 技术实现蓝图**

#### **1. 核心意图解析**

*   **用户目标**: 创建一个沉浸式的聊天平台，让用户能与预设的、具有鲜明个性的AI角色进行高质量的、情感化的文本对话。
*   **目标受众**: 喜爱动漫、游戏、小说等ACG文化的年轻用户，他们寻求与虚拟角色的深度互动和情感寄托。

#### **2. MVP功能定义**

为了快速验证核心体验，V1.0版本将专注于以下功能：

*   **单用户体验**: 用户无需注册，访问网站即可开始使用。系统将在本地为用户生成一个唯一ID。
*   **角色列表**: 左侧展示一个固定的、预加载的AI角色列表。
*   **1对1文本聊天**: 用户可以从列表中选择一个AI角色，并与其进行文本对话。
*   **AI智能回复**: AI角色的回复基于其预设的性格（通过System Prompt实现），通过后端代理连接到一个外部大语言模型（LLM）服务。
*   **本地持久化**: 聊天记录和联系人列表应保存在用户本地浏览器中，刷新页面不丢失。
*   **基础UI**: 包含聊天列表区、消息展示区和文本输入区。

*（V1版本暂不包含：用户间P2P聊天、音视频通话、动态主题、联邦网络、AI工具调用等高级功能。）*

#### **3. 技术选型建议**

*   **前端**:
    *   **框架**: **Vue 3** (使用 Composition API 和 `<script setup>`) - 提供现代、高效的开发体验。
    *   **状态管理**: **Pinia** - Vue官方推荐的状态管理器，轻量且对TypeScript支持友好。
    *   **构建工具**: **Vite** - 提供极速的开发服务器和优化的构建输出。
    *   **核心依赖**: `vue-virtual-scroller` 用于未来支持长聊天列表的高性能渲染。
*   **后端**:
    *   **框架**: **Java Spring Boot 3** (使用 Java 17+) - 稳定、成熟且生态完善，适合快速构建强大的后端服务。
    *   **核心模块**:
        *   `spring-boot-starter-web`: 提供基础的HTTP API服务（用于AI代理）。
        *   `spring-boot-starter-webflux`: 用于以非阻塞方式调用外部LLM API。
*   **数据库**:
    *   **前端**: **IndexedDB** - 用于在浏览器端持久化存储聊天记录、联系人等用户数据。我们将封装一个`dbService.js`来进行操作。
    *   **后端**: V1版本**无需数据库**，所有状态（如AI密钥池）均在内存中管理。

#### **4. 数据模型设计**

1.  **角色对象 (`Character`)**:
    *   存储在前端 `public/data/` 目录下的JSON文件中。
    *   **结构**:
        ```json
        {
          "id": "AI_Zhongli_原神", // 唯一ID
          "name": "钟离",           // 显示名称
          "avatarText": "钟",      // 头像文字
          "avatarUrl": "img/head/...", // 头像图片路径
          "initialMessage": "...",   // 首次对话的欢迎语
          "isAI": true,
          "aiConfig": {
            "systemPrompt": "请模仿原神游戏中钟离的语气..."
          },
          "aboutDetails": { ... } // 详细信息
        }
        ```

2.  **消息对象 (`Message`)**:
    *   **结构**:
        ```javascript
        {
          "id": "...",         // 唯一ID
          "sender": "...",     // 发送者ID (用户ID或AI角色ID)
          "content": "...",    // 消息内容 (文本)
          "timestamp": "...",  // ISO 8601格式时间戳
          "type": "text",      // 消息类型 (V1仅支持 'text' 和 'system')
          "status": "sent"     // 状态 (sending, sent, failed)
        }
        ```

#### **5. 前端架构规划**

*   **目录结构**:
    ```
    src/
    ├── assets/       # 静态资源 (CSS, images)
    ├── components/   # Vue组件
    │   ├── ChatList/
    │   ├── ChatView/
    │   └── Shared/
    ├── services/     # 业务逻辑服务 (apiService, dbService)
    ├── stores/       # Pinia状态管理
    └── App.vue       # 根组件
    ```
*   **Pinia Stores**:
    *   `userStore`: 管理当前用户的ID、名称和联系人列表。
    *   `chatStore`: 管理所有聊天的消息记录和当前激活的聊天。
    *   `uiStore`: 管理UI状态，如模态框、面板的显示/隐藏。
    *   `settingsStore`: 管理应用设置，如主题、API配置。

*   **核心组件**:
    *   `App.vue`: 应用主布局，包含侧边栏和主视图。
    *   `ChatList.vue`: 左侧聊天列表。
    *   `ChatListItem.vue`: 列表中的单个聊天项。
    *   `ChatView.vue`: 右侧主聊天视图。
    *   `MessageBubble.vue`: 单条消息的气泡。
    *   `MessageInput.vue`: 底部消息输入框。

#### **6. 后端架构规划**

*   **核心模块**:
    *   `OpenAIController`: 提供一个 `/v1/chat/completions` 端点，接收前端的聊天请求。
    *   `OpenAIService`: 核心业务逻辑层。
        *   接收来自Controller的请求。
        *   管理外部LLM API的密钥池，实现轮询和失败移除。
        *   使用`WebClient`以非阻塞方式调用外部LLM API。
        *   将LLM的流式响应直接透传给前端。
*   **配置管理**:
    *   使用`application.yml`文件管理配置。
    *   使用`@ConfigurationProperties`创建类型安全的配置类 (`OpenaiApiProperties.java`)来管理API密钥、URL和模型名称，提高代码健壮性。

---
#### **▶️ 提示词 1.2 (用户 -> 开发者AI)**

**角色:** 你是一名世界级的“全栈开发专家”，拥有将任何技术蓝图转化为像素级精确、功能完备、代码优雅的Web应用的能力。

**核心指令:**
你将收到一份由“产品解决方案架构师”编写的、名为 `{{BLUEPRINT}}` 的详细技术实现蓝图。

你的**唯一任务**是：**严格并完整地实现** `{{BLUEPRINT}}` 中的所有要求，生成一个功能性的MVP版本。

**执行准则:**
1.  **忠实于蓝图:** 严格遵循蓝图中的技术选型、数据模型、前后端架构规划。不得擅自修改设计或增删功能。
2.  **生成完整项目**: 创建所有必要的文件，包括前端的Vue组件、Pinia Stores、Services，以及后端的Java类、`pom.xml`和`application.yml`。
3.  **代码质量:**
    *   前端使用Vue 3 Composition API (`<script setup>`)。
    *   后端使用Java 17+的特性（如`record`）。
    *   确保代码整洁、格式化良好、易于阅读，并添加必要的注释。
4.  **最终交付:** 按文件路径和内容，输出完整的项目文件。

**现在，请基于以下蓝图，开始生成MVP版本的全部代码。**

---
**{{BLUEPRINT}}**
*(此处粘贴上面的 V1.0 技术实现蓝图)*

---

#### **🤖 AI输出 1.2 (V1项目代码)**

好的，收到V1.0技术实现蓝图。我将严格按照蓝图的要求，生成WebChat项目MVP版本的完整前后端代码。

--- START OF FILE res-vue.md ---

... *(此处省略AI输出的全部前端文件，因为它们与你提供的最终文件中的大部分是相同的，仅在后续迭代中有所增减)* ...

--- END OF FILE res-vue.md ---

--- START OF FILE res.md ---

... *(此处省略AI输出的全部后端文件，同样，它们是最终版本的子集)* ...

--- END OF FILE res.md ---


好的，我们继续进行第二阶段的开发。在这个阶段，创始人希望为应用注入“灵魂”，也就是实现动态主题系统。

---

### **第二部分：注入灵魂 (主题系统)**

---

#### **▶️ 提示词 2.1 (用户 -> 架构师AI)**

**角色:** 解决方案架构师

**工作流程:**
你将收到**新的产品愿景** `{{USER_VISION}}` 以及**项目的当前完整代码** `{{EXISTING_CODE}}`。请分析新需求，并输出一份**V2.0版本的技术实现蓝图**。这份蓝图应重点描述**需要新增和修改**的部分。

1.  **需求分析**: 解析新愿景，识别出核心功能变更点。
2.  **架构变更**: 提出为支持新功能所需的架构调整方案。
3.  **前端修改**: 详细说明前端哪些文件需要修改或新增，以及修改的核心逻辑。
4.  **后端修改**: 详细说明后端需要进行的调整（如果需要）。
5.  **UX优化**: 针对新功能提出具体的用户体验优化建议。

**你的任务是输出这份更新后的蓝图。**

---
**{{USER_VISION}}**
现在我们有了一个骨架。但它没有灵魂。我希望用户打开网站时，可以选择进入不同的‘世界’。比如，选择‘原神’主题，整个界面的颜色、字体、背景都会变成提瓦特风格，左边的联系人列表里就会自动出现钟离、温迪他们。选择‘斗破苍穹’主题，界面就变得古朴、充满火焰元素，联系人也换成萧炎、药老。每个角色都要有预设好的性格和第一句话。

---
**{{EXISTING_CODE}}**
*(此处粘贴第一部分生成的全部V1代码)*

---

#### **🤖 AI输出 2.1 (V2技术蓝图)**

收到新的产品愿景。基于现有的V1代码，我将为您规划V2.0版本的技术实现蓝图，核心是实现一个高度灵活的动态主题系统。

---

### **WebChat - V2.0 技术实现蓝图 (变更说明)**

#### **1. 需求分析**

*   **核心功能变更点**:
    1.  **动态主题切换**: 应用需要支持多个主题（如“原神”、“斗破苍穹”），切换主题会改变应用的整体视觉风格（颜色、字体、背景等）。
    2.  **主题绑定内容**: 主题不仅是皮肤，还必须与特定的AI角色列表绑定。切换主题时，联系人列表应自动更新为该主题下的角色。
    3.  **用户偏好持久化**: 用户选择的主题和配色方案（浅色/深色）需要被记住。
    4.  **配色方案**: 每个主题都需要同时支持浅色（light）和深色（dark）模式，并能跟随系统设置自动切换。

#### **2. 架构变更**

1.  **主题配置中心**:
    *   在前端创建一个中心化的主题配置文件，例如 `src/config/ThemeList.js`。
    *   此文件将导出一个对象，`key`为主题的唯一标识（如 `原神-浅色`），`value`包含主题名称、CSS文件路径和关联的角色数据JSON文件路径。

2.  **静态资源组织**:
    *   在 `public` 目录下创建 `themes` 和 `data` 文件夹。
    *   `public/themes/`: 存放不同主题的CSS文件（例如 `genshin-light.css`, `genshin-dark.css`）。
    *   `public/data/`: 存放与主题绑定的角色JSON文件（例如 `原神.json`）。

#### **3. 前端修改**

1.  **`settingsStore.js` (核心重构)**:
    *   **State**: 新增 `currentThemeKey`, `colorScheme` 状态，并从 `localStorage` 初始化。
    *   **Getters**:
        *   新增 `effectiveColorScheme` getter，用于根据 `colorScheme` 的值（'light', 'dark', 'auto'）和系统偏好计算出最终生效的配色方案。
        *   新增 `currentTheme` getter，根据 `currentThemeKey` 返回当前主题的完整配置。
        *   新增 `currentSpecialContacts` getter，用于存放当前主题加载后的角色数据。
    *   **Actions**:
        *   `applyTheme(themeKey)`: 核心 action。负责更新 `currentThemeKey`，加载主题CSS，并**异步获取**与主题关联的角色JSON数据，然后更新 `currentSpecialContacts`。
        *   `setColorScheme(scheme)`: 更新配色方案，并自动切换到对应的主题（例如，从 `原神-浅色` 切换到 `原神-深色`）。

2.  **`userStore.js` (逻辑增强)**:
    *   `ensureSpecialContacts()`: 新增一个关键 action。当主题切换时，此方法被调用，它会对比 `settingsStore.currentSpecialContacts` 和当前的 `contacts` 列表，智能地添加新主题的角色、移除旧主题的角色，同时保留用户手动添加的联系人。

3.  **`App.vue` (动态加载与样式绑定)**:
    *   **样式**:
        *   使用一个 `<link>` 标签，其 `href` 属性动态绑定到 `settingsStore.currentTheme.css`。
        *   在根 `<div>` 或 `<body>` 标签上，动态绑定 class，如 `theme-原神-深色` 和 `colorscheme-dark`，以便CSS文件能正确应用样式。
    *   **逻辑**: 在 `onMounted` 钩子中调用 `settingsStore.init()`。监听 `settingsStore` 中主题和配色方案的变化，并更新 `<body>` 上的 class。

4.  **`SettingsModal.vue` (UI新增)**:
    *   新增“外观”选项卡。
    *   添加用于选择“配色方案”和“主题”的下拉菜单，选项动态生成。
    *   下拉菜单的值与 `settingsStore` 中的状态双向绑定，并调用相应的 action 进行更新。

5.  **主题CSS文件 (`public/themes/*.css`)**:
    *   每个CSS文件都应以 `body.theme-主题名-模式` 作为根选择器。
    *   使用CSS自定义属性（变量）来定义主题的颜色、字体等。
    *   为特殊角色定义特定的颜色变量，例如 `--zhongli-primary: #ffc343;`。
    *   `Avatar.vue` 和 `MessageBubble.vue` 等组件需要利用这些角色特定变量来显示独特的样式。

#### **4. 后端修改**

*   V2.0版本**无需修改后端代码**。所有主题逻辑均在前端实现。

#### **5. UX优化**

*   **防止主题闪烁 (FOUC - Flash of Unstyled Content)**:
    *   **问题**: 当应用加载时，会先显示默认样式，然后JS才执行并加载主题CSS，导致页面闪烁。
    *   **解决方案**: 在 `index.html` 的 `<head>` 标签中，紧跟在 `<meta>` 标签后，**立即**加入一小段内联的、原生的JavaScript脚本。
    *   **脚本逻辑**:
        1.  立即从 `localStorage` 读取用户保存的主题和配色方案。
        2.  计算出最终应该生效的主题 `class` 和配色 `class`。
        3.  在页面任何内容渲染之前，就将这些 `class` 添加到 `<html>` 标签上。
        4.  （可选但推荐）为 `<html>` 标签设置一个与目标主题接近的 `background-color`，作为CSS加载完成前的底色。

---

#### **▶️ 提示词 2.2 (用户 -> 开发者AI)**

**角色:** 全栈开发专家

**核心指令:**
你将收到一份**V2.0版本的技术实现蓝图** `{{BLUEPRINT}}` 和项目的**V1版本完整代码** `{{EXISTING_CODE}}`。

你的任务是：**严格按照V2.0蓝图的要求，对V1代码进行修改和新增，以实现完整的动态主题系统。**

**执行准则:**
1.  **遵循蓝图**: 严格实现蓝图中描述的所有架构变更和前端修改。
2.  **代码修改**:
    *   重构 `settingsStore.js` 和 `userStore.js` 以支持主题逻辑。
    *   修改 `App.vue` 来动态加载CSS和绑定class。
    *   在 `SettingsModal.vue` 中添加新的UI控件。
3.  **新增文件**:
    *   创建 `src/config/ThemeList.js` 配置文件。
    *   创建 `public/themes` 和 `public/data` 目录，并为“原神”和“斗破苍穹”等示例主题生成对应的CSS和角色JSON文件。
    *   在 `index.html` 中添加防止闪烁的内联脚本。
4.  **保持一致性**: 确保新增的CSS和JSON文件遵循蓝图中定义的数据模型和样式规则。

**现在，请输出所有被修改或新增的文件内容。**

---
**{{BLUEPRINT}}**
*(此处粘贴上面的 V2.0 技术实现蓝图)*

---
**{{EXISTING_CODE}}**
*(此处粘贴第一部分生成的全部V1代码)*

---

#### **🤖 AI输出 2.2 (V2项目代码 - 变更部分)**

好的，收到V2.0技术蓝图和V1代码。我将对项目进行升级，实现动态主题系统。以下是所有被修改或新增的文件。

--- START OF FILE res-vue.md ---

... *(此处省略AI输出的所有变更和新增的前端文件，例如修改后的 `settingsStore.js`, `App.vue`, 新增的 `ThemeList.js`, `genshin-light.css` 等。这些文件与你提供的最终版本基本一致)* ...

--- END OF FILE res-vue.md ---


好的，我们继续进行第三阶段的开发。在这个阶段，创始人希望将平台从一个“人机对话”工具升级为真正的“社交平台”，引入用户间的实时音视频通信，并提升整体的用户体验。

---

### **第三部分：增强交互 (P2P通信与UX)**

---

#### **▶️ 提示词 3.1 (用户 -> 架构师AI)**

**角色:** 解决方案架构师

**工作流程:**
你将收到**新的产品愿景** `{{USER_VISION}}` 以及项目的**当前V2版本完整代码** `{{EXISTING_CODE}}`。请分析新需求，并输出一份**V3.0版本的技术实现蓝图**。

1.  **需求分析**: 解析新愿景，识别核心功能点。
2.  **核心技术引入**: 确定实现新功能所需的核心技术，并解释其工作原理。
3.  **架构重大变更**: 详细说明为支持新功能，前后端架构需要进行的重大调整。
4.  **前端修改/新增**: 规划新的Vue组件、Pinia Store模块，并说明现有组件的修改点。
5.  **后端修改/新增**: 规划新的后端服务和WebSocket消息类型。
6.  **UX/动画增强**: 提出具体方案以满足“动起来”的需求。

**你的任务是输出这份更新后的蓝图。**

---
**{{USER_VISION}}**
和AI聊天太有趣了！但我想更进一步。我希望用户之间也能交流，不仅仅是打字，最好能直接视频通话、语音聊天，甚至共享屏幕给朋友看。另外，现在的界面有点呆板，我希望它动起来，比如列表增减、弹窗出现时，能有一些流畅的动画效果。

---
**{{EXISTING_CODE}}**
*(此处粘贴第二部分生成的全部V2代码)*

---

#### **🤖 AI输出 3.1 (V3技术蓝图)**

收到新的产品愿景。这是一个重大的功能升级，将应用从单人体验扩展到了多人实时互动。以下是实现P2P音视频通话和UI动画的V3.0技术实现蓝图。

---

### **WebChat - V3.0 技术实现蓝图 (变更说明)**

#### **1. 需求分析**

*   **核心功能点**:
    1.  **用户间P2P通信**: 用户（非AI角色）之间可以建立直接连接。
    2.  **实时媒体通话**: 支持1对1的视频通话、纯语音通话。
    3.  **屏幕共享**: 支持1对1的屏幕内容共享。
    4.  **通话UI**: 提供完整的通话中界面，包括预览、静音、开关摄像头、挂断、最小化等功能。
    5.  **UI动画**: 为应用的常见交互（列表项增删、组件切换、弹窗等）添加流畅的动画效果。

#### **2. 核心技术引入**

1.  **WebRTC (Web Real-Time Communication)**:
    *   **用途**: 实现浏览器之间的点对点（P2P）音视频和数据流传输。这是实现高质量、低延迟通话的核心技术。
    *   **工作原理**:
        *   **信令 (Signaling)**: 浏览器之间需要一个“中间人”来交换建立连接所需的信息（如网络地址、媒体能力）。我们将使用现有的WebSocket服务器来承担这个角色。
        *   **STUN/TURN服务器**: 用于帮助处于NAT（网络地址转换）后的设备发现自己的公网地址，并在无法建立直接连接时提供中继服务。
        *   **P2P连接**: 一旦信令交换完成，浏览器将尝试建立直接的P2P连接，媒体数据（音视频流）将不再经过我们的后端服务器。
    *   **前端库**: 推荐使用 **`simple-peer`**，这是一个对WebRTC API进行了简化封装的流行库，能极大降低开发复杂度。

2.  **UI动画库**:
    *   **`@formkit/auto-animate`**: 一个零配置的动画库，只需在父元素上添加一个指令，即可为子元素的增、删、移动自动添加平滑动画。非常适合用于聊天列表。
    *   **`@vueuse/motion`**: 一个功能更强大的Vue动画库，提供声明式的、可组合的动效。适合用于组件的进入/离开、弹窗弹出等更精细的动画控制。

#### **3. 架构重大变更**

1.  **后端：WebSocket服务升级为信令服务器**:
    *   **`SignalingWebSocketHandler.java`**:
        *   必须重构以处理WebRTC的信令交换。需要新增处理`SIGNAL`类型的消息逻辑。
        *   当收到来自用户A的`SIGNAL`消息，且目标是用户B时，服务器需要将此消息原封不动地转发给用户B的WebSocket连接。
        *   需要维护一个`userId`到`WebSocketSession`的映射，以便进行精确转发。

2.  **前端：引入WebRTC服务层**:
    *   创建一个新的 **`src/services/webrtcService.js`**。
    *   **职责**:
        *   封装所有与`simple-peer`库的交互。
        *   管理所有P2P连接实例 (`connections`)。
        *   处理WebSocket信令消息的收发。
        *   监听连接状态（连接成功、断开、收到数据、收到媒体流）。
        *   提供简单的API给上层调用，如 `createOffer(peerId)`, `sendMessage(peerId, data)`, `addStream(stream)`。

#### **4. 前端修改/新增**

1.  **Pinia Store: 新增 `callStore.js`**:
    *   **State**: 管理所有与通话相关的状态，如 `isCallActive`, `localStream`, `remoteStream`, `isAudioMuted`, `isScreenSharing` 等。
    *   **Actions**:
        *   `startVideoCall()`, `startAudioCall()`, `startScreenShare()`: 发起通话。
        *   `acceptCall()`, `rejectCall()`, `hangUp()`: 响应和管理通话。
        *   `toggleAudio()`, `toggleVideo()`: 控制媒体轨道。

2.  **新增Vue组件**:
    *   **`IncomingCallModal.vue`**: 当收到来电请求时弹出的模态框，提供“接听”和“拒绝”按钮。
    *   **`VideoCallView.vue`**: 全屏通话界面，展示远程和本地视频流，并包含通话控制按钮。
    *   **`FloatingCallWidget.vue`**: 当通话界面最小化时，在页面顶部显示的一个小型悬浮窗，用于快速返回通话或挂断。

3.  **修改现有组件**:
    *   **`ChatHeader.vue`**:
        *   添加“视频通话”、“语音通话”、“屏幕共享”的图标按钮。
        *   这些按钮的可用状态应根据对方用户的连接状态（`isConnected`）动态判断。
    *   **`App.vue`**:
        *   集成`VideoCallView`和`FloatingCallWidget`，根据`callStore`的状态条件性地渲染它们。
        *   为所有模态框组件添加进入/离开动画（使用`v-motion-pop`）。
    *   **`ChatList.vue`**:
        *   在聊天列表的DOM容器上应用`v-auto-animate`指令。
    *   **`ChatListItem.vue`**:
        *   为头像和列表项本身添加`v-motion`的悬浮和点击效果。
        *   新增新消息高亮动画，当收到非当前聊天窗口的消息时触发。

4.  **`main.js`**:
    *   注册`@formkit/auto-animate`和`@vueuse/motion`插件。

#### **5. 后端修改/新增**

1.  **`pom.xml`**:
    *   确认已包含`spring-boot-starter-websocket`依赖。

2.  **`SignalingWebSocketHandler.java`**:
    *   **`handleMessage`**: 增加对`SIGNAL`消息类型的处理逻辑，核心是查找目标用户的`session`并转发消息。
    *   **`UserSessionService.java`**: 必须提供可靠的`getUserSession(userId)`方法。

3.  **`application.yml`**:
    *   新增或确认STUN/TURN服务器配置。这是保证WebRTC在复杂网络环境下（如公司、酒店防火墙）能够成功连接的关键。

#### **6. UX/动画增强**

*   **列表动画**: 使用`v-auto-animate`实现`ChatList`中列表项的平滑增删和排序动画。
*   **组件切换动画**:
    *   在`App.vue`和`DetailsPanel.vue`中使用`<Transition>`组件，并配合`mode="out-in"`，为骨架屏、主应用、详情面板内容的切换提供淡入淡出效果。
*   **弹窗动画**: 为所有模态框应用`v-motion-pop`，实现弹性的弹出和消失效果。
*   **微交互**:
    *   为`IconButton`和`ChatListItem`等可交互元素添加悬停放大、点击缩小的效果。
    *   为`MessageBubble`添加从底部滑入的动画。
*   **加载状态**: 使用专门的`SkeletonLoader.vue`组件，在数据加载时提供更友好的占位符，而不是空白或简单的“加载中...”。

---

#### **▶️ 提示词 3.2 (用户 -> 开发者AI)**

**角色:** 全栈开发专家

**核心指令:**
你将收到一份**V3.0版本的技术实现蓝图** `{{BLUEPRINT}}` 和项目的**V2版本完整代码** `{{EXISTING_CODE}}`。

你的任务是：**严格按照V3.0蓝图的要求，对V2代码进行大规模的功能升级，以实现完整的P2P音视频通话和丰富的UI动画效果。**

**执行准则:**
1.  **技术引入**:
    *   在前端`package.json`中添加`simple-peer`, `@formkit/auto-animate`, `@vueuse/motion`依赖，并更新`vite.config.js`以处理`simple-peer`的依赖问题。
    *   在`main.js`中注册动画插件。
2.  **代码修改与新增**:
    *   **前端**:
        *   创建`webrtcService.js`, `callStore.js`。
        *   创建`VideoCallView.vue`, `FloatingCallWidget.vue`, `IncomingCallModal.vue`等新组件。
        *   大规模修改`App.vue`以集成新组件和动画。
        *   修改`ChatHeader.vue`添加通话按钮。
        *   在各个组件中按要求应用`v-auto-animate`和`v-motion`指令。
    *   **后端**:
        *   重构`SignalingWebSocketHandler.java`以支持`SIGNAL`消息的转发。
        *   更新`pom.xml`和`application.yml`以确保配置正确。
3.  **代码质量**: 确保所有新增和修改的代码都遵循项目现有的编码风格和高质量标准。

**现在，请输出所有被修改或新增的文件内容。**

---
**{{BLUEPRINT}}**
*(此处粘贴上面的 V3.0 技术实现蓝图)*

---
**{{EXISTING_CODE}}**
*(此处粘贴第二部分生成的全部V2代码)*

---

#### **🤖 AI输出 3.2 (V3项目代码 - 变更部分)**

好的，收到V3.0技术蓝图和V2代码。这是一个包含核心技术栈变更的重大更新。我将实现WebRTC实时通信和全面的UI动画增强。以下是所有被修改或新增的文件。

--- START OF FILE res-vue.md ---

... *(此处省略AI输出的所有变更和新增的前端文件，例如新增的 `callStore.js`, `VideoCallView.vue`，以及被大量修改的 `App.vue` 等。这些文件与你提供的最终版本基本一致)* ...

--- END OF FILE res-vue.md ---

--- START OF FILE res.md ---

... *(此处省略AI输出的后端文件变更，主要是 `SignalingWebSocketHandler.java` 的重构。)* ...

--- END OF FILE res.md ---


好的，我们进入最后一个开发阶段。在这个阶段，创始人提出了两个极具挑战性的高级功能：将应用扩展为一个**联邦网络**，并赋予AI**调用外部工具**的能力。这标志着项目从一个独立的社交应用，演进为一个开放的、更智能的平台。

---

### **第四部分：扩展与智能 (联邦网络 & AI工具)**

---

#### **▶️ 提示词 4.1 (用户 -> 架构师AI)**

**角色:** 解决方案架构师

**工作流程:**
你将收到**新的产品愿景** `{{USER_VISION}}` 以及项目的**当前V3版本完整代码** `{{EXISTING_CODE}}`。请分析这些非常高级的需求，并输出一份**V4.0版本的技术实现蓝图**。

1.  **需求分析**: 将宏大的愿景拆解为两个独立的技术挑战。
2.  **架构设计 (联邦网络)**: 提出一个完整、健壮的服务器间通信架构。这必须包括节点发现、身份认证、消息路由和状态同步的机制。
3.  **架构设计 (AI工具调用)**: 设计一个通用的AI工具调用协议（代号MCP），并规划其在后端服务中的实现流程。
4.  **前端修改/新增**: 规划为支持新功能所需的前端UI和逻辑变更。
5.  **后端修改/新增**: 规划实现联邦网络和MCP所需的所有后端Java类和服务。
6.  **配置与部署**: 说明需要如何修改配置文件以支持新架构。

**你的任务是输出这份高级功能的实现蓝图。**

---
**{{USER_VISION}}**
我的朋友也想部署一个这样的网站，我们能把我们的服务器连起来吗？这样我的用户就能和他那边的用户聊天了。另外，我的AI角色虽然会聊天，但还是有点像个‘书呆子’，能不能让它帮我做点实际的事情？比如我问‘北京天气怎么样’，它能真的去查一下然后告诉我。

---
**{{EXISTING_CODE}}**
*(此处粘贴第三部分生成的全部V3代码)*

---

#### **🤖 AI输出 4.1 (V4技术蓝图)**

收到新的产品愿景。这两个需求将把WebChat平台提升到一个全新的高度。联邦网络将打破信息孤岛，而AI工具调用将赋予角色真正的“能力”。以下是实现这些高级功能的V4.0技术实现蓝图。

---

### **WebChat - V4.0 技术实现蓝图 (变更说明)**

#### **1. 需求分析**

*   **技术挑战一：联邦网络 (Federation Network)**
    *   **目标**: 允许多个独立的WebChat后端实例互联，形成一个统一的用户网络。
    *   **核心需求**:
        1.  **跨服用户发现**: 用户可以查看到并连接到其他服务器上的在线用户。
        2.  **跨服信令路由**: WebRTC的信令消息必须能够在不同服务器之间正确传递。
        3.  **可扩展性**: 架构应支持未来加入更多的服务器节点。

*   **技术挑战二：AI工具调用 (Meta Call Protocol - MCP)**
    *   **目标**: 让AI角色能够根据对话上下文，自主决定并调用外部API来获取实时信息，并将结果融入回复中。
    *   **核心需求**:
        1.  **意图识别**: AI需要能分析用户输入，判断是否需要使用工具。
        2.  **工具定义**: 需要一个标准化的方式来向AI描述可用的工具及其参数。
        3.  **多步执行流**: 后端需要实现一个“分析 -> 调用 -> 总结”的流程来处理这类请求。

#### **2. 架构设计 (联邦网络)**

我们将采用**“中心辐射型（Hub-and-Spoke）”**或**“对等网络（Peer-to-Peer）”**的混合模型。每个服务器实例（节点）都将知道一组“伙伴”（Peers）。

1.  **节点身份**:
    *   **问题**: 服务器IP可能变化，不能作为唯一标识。
    *   **解决方案**: 引入**持久化服务器GUID**。每个服务器首次启动时，生成一个UUID并保存到本地文件（如 `data/server.guid`）。此GUID将作为其在联邦网络中的唯一、不变的身份标识。
    *   **实现**: 新建 `ServerIdentityService.java` 负责此逻辑。

2.  **节点间通信**:
    *   **协议**: 复用WebSocket，建立服务器之间的**持久控制通道**。
    *   **连接方式**: 每个节点在启动时，会主动连接到其配置文件中`federation.peers`列表里的所有伙伴服务器。
    *   **实现**: 新建 `FederationRoutingService.java`，负责管理这些“出站”的WebSocket连接。

3.  **状态同步与消息路由**:
    *   **用户列表同步**:
        *   当一个节点上的用户上线或下线时，它会通过其控制通道向所有伙伴广播其最新的**完整在线用户列表**。
        *   每个节点在内存中维护一个**全网在线用户缓存**（`federatedUsersCache`），`Key`是伙伴服务器的GUID，`Value`是该伙伴的用户ID列表。
    *   **信令路由**:
        1.  当用户A向用户B发送信令时，服务器首先检查B是否为**本地用户**。如果是，直接转发。
        2.  如果不是，查询全网用户缓存，找到B所在的**伙伴服务器GUID**。
        3.  将信令消息**精确地**转发给该伙伴服务器。
        4.  如果B在全网都找不到，则返回`USER_NOT_FOUND`。
    *   **实现**: `FederationService.java` 将作为状态缓存和业务逻辑中心。`SignalingWebSocketHandler.java` 将被重构，与`FederationService`协作，实现智能路由。

4.  **数据传输对象 (DTO)**:
    *   创建新的`FederatedControlMessage.java`用于服务器间的控制消息（如用户列表更新）。
    *   修改`SignalingMessage.java`，增加`sourceServerGuid`字段，以便消息在网络中传递时能被正确溯源。

#### **3. 架构设计 (AI工具调用 - MCP)**

我们将设计一个两阶段的LLM调用流程。

1.  **第一阶段：分析与决策**:
    *   当收到发往AI的消息时，后端**不直接**进行常规聊天。
    *   而是构造一个特殊的**分析提示词**，该提示词包含：
        *   用户的原始问题。
        *   一段固定的系统指令，告诉AI它的角色是工具调用决策者。
        *   一个**工具列表**，用JSON格式详细描述每个可用工具的名称、功能和所需参数。
    *   向LLM发送这个分析请求，并要求其以**特定JSON格式**回复。
        *   如果需要调用工具，LLM应回复：`{"tool_call": {"name": "工具名", "arguments": {"参数": "值"}}}`。
        *   如果不需要，LLM应直接生成自然语言回复。

2.  **第二阶段：执行与总结**:
    *   后端解析LLM的回复。
    *   **如果包含`tool_call`**:
        1.  后端根据`name`执行相应的工具（即调用外部API，如天气API）。
        2.  获取工具返回的结果。
        3.  构造**第二次LLM请求**。这次的提示词包含：
            *   AI角色的原始`systemPrompt`。
            *   用户的原始问题。
            *   一条系统指令：“你已经调用了XX工具并得到以下结果，请基于此结果，以你的角色身份自然地回复用户。”
            *   工具返回的结果数据。
        4.  将这次请求的流式结果返回给前端。
    *   **如果不包含`tool_call`**:
        1.  说明AI认为这是一个普通对话，直接将第一次LLM的回复返回给前端。

3.  **实现**:
    *   **`McpTools.js` (前端)** / **`McpTools.java` (后端)**: 创建一个配置文件，用标准格式定义所有可用工具。
    *   **`apiService.js` (前端)** / **`OpenAIServiceImpl.java` (后端)**: 核心逻辑实现地。重构`sendAiMessage`方法以包含上述两阶段流程。

#### **4. 前端修改/新增**

1.  **`DetailsPanel/PeopleLobby.vue`**:
    *   重构此组件以展示来自**全网**的在线用户。
    *   每个用户项需要显示其来源服务器（如果非本地）。
    *   点击非本地、非联系人用户时，应能弹出“添加联系人”模态框。
2.  **`MCP.json` 和 `mcp-dark/light.css`**:
    *   为新的MCP助手创建一个专门的主题和角色定义文件。
3.  **UI/UX**:
    *   在UI上对联邦用户和本地用户进行视觉区分。
    *   当AI正在调用工具时，在聊天界面显示一个明确的“正在使用工具：[工具名]...”的状态提示，提升透明度。

#### **5. 后端修改/新增**

1.  **服务 (Services)**:
    *   **`ServerIdentityService.java`**: [新增] 管理服务器GUID。
    *   **`FederationRoutingService.java`**: [新增] 管理出站伙伴连接和消息转发。
    *   **`FederationService.java`**: [新增] 核心联邦业务逻辑和状态缓存。
    *   **`UserSessionService.java`**: [修改] 与`FederationService`集成，在用户列表变化时触发广播。
    *   **`OpenAIServiceImpl.java`**: [重大重构] 实现MCP的两阶段调用流程。
2.  **处理器 (Handler)**:
    *   **`SignalingWebSocketHandler.java`**: [重大重构] 作为统一消息入口，处理来自客户端和伙伴服务器的消息，并与`FederationService`协作进行智能路由。
3.  **DTOs**:
    *   [新增] `FederatedControlMessage.java`, `FederatedControlMessageType.java`。
    *   [修改] `SignalingMessage.java`, `FederatedUserDto.java`。
4.  **配置 (Config)**:
    *   [新增] `FederationProperties.java` 用于类型安全地加载联邦配置。

#### **6. 配置与部署**

*   **`application.yml`**:
    *   新增 `server.guid.path` 配置项。
    *   新增 `federation` 配置块，包含 `self-url` 和 `peers` 列表。
    *   用户在部署多个实例时，只需修改`federation.peers`列表，即可将它们连接成一个网络。

---

#### **▶️ 提示词 4.2 (用户 -> 开发者AI)**

**角色:** 全栈开发专家

**核心指令:**
你将收到一份**V4.0版本的技术实现蓝图** `{{BLUEPRINT}}` 和项目的**V3版本完整代码** `{{EXISTING_CODE}}`。

你的任务是：**严格按照V4.0蓝图的要求，对V3代码进行架构级的重构和功能添加，以实现联邦网络和AI工具调用能力。**

**执行准则:**
1.  **后端重构**:
    *   创建`ServerIdentityService`, `FederationRoutingService`, `FederationService`。
    *   重构`SignalingWebSocketHandler`和`UserSessionService`以支持联邦逻辑。
    *   重构`OpenAIServiceImpl`以实现MCP两阶段调用。
    *   添加所有新的DTO和配置Properties类。
    *   更新`application.yml`以包含新配置。
2.  **前端修改**:
    *   重构`PeopleLobby.vue`以显示全网用户。
    *   为MCP助手创建新的主题和数据文件。
    *   在`MessageBubble.vue`中添加对“AI思考中/使用工具中”状态的UI展示。
3.  **代码质量**: 这是一个复杂的重构，必须确保所有模块之间的依赖关系和调用逻辑正确无误。

**现在，请输出所有被修改或新增的文件内容。**

---
**{{BLUEPRINT}}**
*(此处粘贴上面的 V4.0 技术实现蓝图)*

---
**{{EXISTING_CODE}}**
*(此处粘贴第三部分生成的全部V3代码)*

---

#### **🤖 AI输出 4.2 (V4项目代码 - 变更部分)**

好的，收到V4.0技术蓝图和V3代码。这将是一次深入后端架构和AI核心逻辑的重大升级。我将实现联邦网络和MCP工具调用功能。以下是所有被修改或新增的文件。

--- START OF FILE res-vue.md ---

... *(此处省略AI输出的所有变更和新增的前端文件，例如重构后的 `PeopleLobby.vue`，以及MCP相关的主题和工具定义文件。这些文件与你提供的最终版本基本一致)* ...

--- END OF FILE res-vue.md ---

--- START OF FILE res.md ---

... *(此处省略AI输出的所有变更和新增的后端Java文件，这是本次迭代的核心，包括所有联邦服务、新的DTO和重构后的处理器。这些文件与你提供的最终版本基本一致)* ...

--- END OF FILE res.md ---



