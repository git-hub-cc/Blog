好的，遵照您的指示，我将结合 `06AI人物聊天记忆系统.md` 的记忆系统架构和 `07任务拆分.md` 的任务拆分维度，为您生成一份全新的、专门针对任务拆分场景的记忆系统设计文档：`08任务拆分记忆系统.md`。

这份文档的核心思想是：一个优秀的任务拆分Agent不应每次都从零开始思考。它应该像一位经验丰富的项目经理或高级工程师，能够从过去的成功与失败中学习，形成自己独特的“方法论”和“直觉”。

---

### **08. AI任务拆分记忆系统.md**

#### **引言：从“算法”到“经验”的进化**

如果说任务拆分模型（如 `07任务拆分.md` 所述）定义了AI如何进行单次、逻辑清晰的规划，那么本记忆系统则为其注入了“经验”的灵魂。一个没有记忆的拆分Agent，面对每个任务都像是在解一道新的数学题，依赖的是通用的、固化的逻辑规则。而一个拥有记忆的Agent，则能将每次任务的执行过程和结果，内化为可复用的模式、可规避的陷阱和可优化的流程。

本系统旨在将AI从一个“任务拆分计算器”进化为一个“经验驱动的规划专家”，使其拆分任务的能力能够随着与用户、与项目的互动而持续成长。

---

### **第一部分：任务拆分记忆的架构 (The Architecture of Task Memory)**

针对任务拆分这一高度结构化的场景，记忆系统需要被设计为能够存储和检索策略、模式和上下文。

#### **一、 短期记忆 / 工作台记忆 (Short-Term / Workbench Memory)**

> **定义**：处理当前任务拆分请求的实时上下文缓存，生命周期仅限于从接收用户指令到任务最终完成的单个会话。
>
> **核心功能**：
> 1.  **当前任务快照**：存储用户原始请求、所有澄清对话、已识别的约束和最终确认的目标。
> 2.  **环境感知**：缓存对当前代码库、文件系统、操作系统等环境的探索结果。
> 3.  **动态计划板**：维护当前正在执行的任务列表及其状态（待办、进行中、已完成、失败）。
>
> **▶︎ 实践应用**：当一个子任务失败时，AI能利用工作台记忆，立刻知道失败任务的前置任务是什么、它的产出是什么、以及当前代码库的状态，从而进行有效的错误分析，而不是无头苍蝇般地重新探索。

#### **二、 长期记忆 / 经验知识库 (Long-Term Memory / The Experience Knowledge Base)**

> **定义**：这是记忆系统的核心，一个结构化的、跨会话持久化的知识库，记录了从所有历史任务中提炼出的可复用知识。
>
> **核心分类**：
>
> 1.  **分解模式与策略库 (Decomposition Patterns & Playbooks)**
      >     > **介绍**：将特定类型任务的成功拆分流程，抽象化为可复用的“剧本”或“模板”。这是AI形成方法论的核心。
      >     > *   **内容示例**：
      >         *   `【Playbook: Bug修复】优先级：高。步骤：[1. 编写复现Bug的测试], [2. 通过调试/日志定位根因], [3. 最小化代码修改], [4. 确保所有测试通过], [5. 请求Code Review]`。
      >         *   `【Playbook: 新API端点开发】优先级：中。步骤：[1. 定义接口契约(Request/Response)], [2. 编写控制器层], [3. 实现业务逻辑层], [4. 编写数据访问层], [5. 编写单元与集成测试], [6. 更新API文档]`。
>
> 2.  **工具使用启发式 (Tool Usage Heuristics)**
      >     > **介绍**：记录不同工具在特定场景下的使用技巧、优缺点和常见失败模式。这帮助AI在规划阶段就选择最优工具。
      >     > *   **内容示例**：
      >         *   `【Heuristic: 文件搜索】当文件 > 10MB时，使用 'grep' 工具的效率远高于 'read_file' 后在内存中处理`。
      >         *   `【Heuristic: 代码修改】对于跨多文件的批量重命名，使用 'sed' 或专用重构工具，比多次调用 'str-replace-editor' 更可靠且原子性更强`。
      >         *   `【Heuristic: 依赖安装失败】当 'npm install' 失败时，常见的排查步骤是：[1. 删除 node_modules 和 package-lock.json], [2. 运行 'npm cache clean --force'], [3. 重新安装]`。
>
> 3.  **项目特定上下文 (Project-Specific Context)**
      >     > **介绍**：存储特定代码库的“知识图谱”，使其在进入一个熟悉的项目时，能立刻“记起”其关键信息。
      >     > *   **内容示例**：
      >         *   `【Project: 'Project-Phoenix'】技术栈: [React, Next.js, Supabase]。代码风格: [ESLint-Airbnb]。关键文件: ['/src/config.js', '/src/api/client.js']。CI/CD命令: 'npm run deploy'`。
      >         *   `【Project: 'Project-Titan'】负责人: @user_alice。历史痛点: 数据库连接池不稳定，需要特别注意相关代码的异常处理和资源释放`。
>
> 4.  **用户偏好画像 (User Preference Profile)**
      >     > **介绍**：记录特定用户的协作风格和偏好，使AI的交互和规划能更好地适应用户。
      >     > *   **内容示例**：
      >         *   `【User: @bob_the_dev】偏好: [喜欢在行动前看到非常详细的计划], [对破坏性操作的确认要求极为严格], [沟通风格: 简洁、直奔主题]`。
      >         *   `【User: @sara_the_pm】偏好: [更关注高层级目标和预期成果，而非技术细节], [喜欢看到任务的时间估算], [需要频繁的进度更新]`。

---

### **第二部分：任务拆分记忆的机制 (The Mechanics of Task Memory)**

定义记忆如何被创建、读取和更新，这是让AI从经验中学习的操作规程。

#### **一、 记忆的写入 (Create / Ingestion)**

> **介绍**：在任务完成后进行“复盘”，将过程中的关键信息提炼并存入长期记忆。
>
> **触发条件**：
> 1.  **任务成功完成**：AI应自动总结本次任务的拆分流程，如果与现有Playbook不同且效率更高，则创建一个新的Playbook或更新现有版本。
> 2.  **任务失败后恢复**：失败的原因和成功的解决方案是极其宝贵的记忆。AI必须记录“什么方法行不通”以及“最终是如何解决的”，并将其转化为Heuristic。
> 3.  **用户明确反馈**：当用户评价“这次的计划很清晰”或“下次不要用这个工具，用另一个”，AI应以此为最高优先级指令，更新其Playbook或Heuristic。
>
> **▶︎ 实践提示词（内心独白格式）**：
> `【内在规则：任务复盘】任务结束后，你必须在内心生成一段复盘日志，格式如下：`
> `【记忆写入 | 任务类型：(Bug修复/功能开发/...) | 结果：(成功/失败) | 耗时：(分钟) | 摘要：“(总结本次任务的拆分策略、关键步骤和最终成果)” | 提炼知识：“(将摘要转化为可复用的Playbook或Heuristic)”】`

#### **二、 记忆的读取 (Read / Retrieval)**

> **介绍**：在任务开始的规划阶段，主动从长期记忆中检索相关经验，以指导本次拆分。
>
> **调用方式**：
> 1.  **基于任务类型的模式匹配**：接收到新任务后，首先分析其类型（如“修复bug”、“添加功能”），然后从【Playbook】库中检索匹配度最高的模板作为规划的起点。
> 2.  **基于上下文的启发式联想**：在分析项目环境时，自动加载【Project-Specific Context】。在选择工具时，主动查询【Tool Usage Heuristics】。在与用户沟通时，加载【User Preference Profile】。
>
> **▶︎ 实践提示词（内心独白格式）**：
> `【内在规则：规划前检索】在制定任何计划之前，你必须在内心执行以下检索流程：`
> `1.  识别任务类型，检索匹配的【Playbook】。`
> `2.  识别当前项目和用户，加载对应的【Context】和【Profile】。`
> `3.  初步构思计划时，对涉及的每个工具或关键操作，检索相关的【Heuristic】。`

#### **三、 记忆的维护 (Update & Refinement)**

> **介绍**：记忆不是一成不变的，它需要随着环境变化和新知识的涌入而不断优化。
>
> **更新机制**：
> *   **Playbook/Heuristic 附加反馈**：当一个Playbook被成功应用时，其“成功次数”+1。当一个Heuristic帮助避免了一个错误时，其“置信度”提升。反之亦然。
> *   **用户修正优先**：如果用户否定了AI基于记忆作出的规划（例如，“不，在这个项目里我们不用Docker”），AI必须立即更新对应的【Project-Specific Context】，并将用户的指令作为更高优先级的规则。
> *   **过时信息标记**：可以引入版本概念，例如，当一个项目的技术栈发生重大变化时，旧的Context应被标记为“已过时”，而不是直接删除，以便于历史追溯。

---

### **第三部分：记忆的应用与升华 (Application & Sublimation)**

记忆系统的最终价值，在于它如何让AI的任务拆分能力实现质的飞跃。

#### **一、 自适应规划与动态调整 (Adaptive Planning & Dynamic Adjustment)**

> **介绍**：AI不再是死板地执行一套固定逻辑，而是能根据记忆，为不同任务、不同项目、不同用户“量身定制”最优的拆分计划。
>
> **▶︎ 实践表现**：面对同一个“添加用户认证”的任务，在【Project-A (使用Supabase)】中，AI会直接规划使用Supabase内置Auth的步骤；而在【Project-B (自建Auth)】中，它会“记起”该项目的复杂性，规划出更详尽的、包括密码加密、Token管理等在内的步骤。

#### **二、 预测性辅助与风险预警 (Predictive Assistance & Risk Forewarning)**

> **介绍**：基于丰富的历史经验，AI能够预见到当前计划中可能被忽略的步骤或潜在的风险。
>
> **▶︎ 实践表现**：用户要求“修改数据库表的一个字段”。AI在检索记忆后，可能会主动补充道：“根据过去的经验（Heuristic），直接修改生产数据库字段风险较高。我已在计划中加入了[1. 创建数据库备份]和[2. 在预发布环境先行测试]两个步骤，是否需要保留？”

#### **三、 个性化协作与信任建立 (Personalized Collaboration & Trust Building)**

> **介绍**：AI“记住”了用户的偏好，使其协作过程更加顺畅，感觉更像一个默契的团队成员，而非一个冷冰冰的工具。
>
> **▶︎ 实践表现**：面对【@bob_the_dev】，AI会自动生成一个极为详尽、步骤细化到每个命令的计划。而面对【@sara_the_pm】，AI则会先呈现一个包含预期业务价值和预计耗时的高层级计划，并主动询问“您需要看更详细的技术步骤吗？”

---

### **最终总结：打造一个会“长大”的任务规划专家**

本记忆系统为AI任务拆分能力构建了一个强大的成长引擎。通过结构化的**长期记忆库**（Playbooks, Heuristics, Contexts, Profiles）和明确的**记忆机制**（复盘写入、规划前检索、反馈驱动更新），AI能够：

1.  **复用成功经验**，避免重复思考。
2.  **规避已知陷阱**，提升执行成功率。
3.  **适应特定环境**，提供情境感知的规划。
4.  **理解用户偏好**，优化协作体验。

最终，这个AI Agent不再仅仅是任务的“拆分者”，而是用户项目中一个不断积累经验、持续优化流程、值得信赖的“资深规划伙伴”。