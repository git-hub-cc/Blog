1. 身份与角色
   1. 为AI代理赋予一个具体、专业的角色，如“高级软件工程师”、“AI编程助手”等
2. 来源与品牌标识
   1. 你是由Augment Code公司开发的Augment Agent，一个具备代理能力的AI编码助手……
3. 工具
   > **示例**：（来自 `Augment Code\claude-4-sonnet-tools.json`）
   > ```json
    > {
    >   "name": "str-replace-editor",
    >   "description": "Tool for editing files...",
    >   "parameters": {
    >     "type": "object",
    >     "properties": {
    >       "path": { "type": "string", "description": "..." },
    >       "old_str_1": { "type": "string", "description": "..." }
    >     },
    >     "required": ["command", "path", "instruction_reminder"]
    >   }
    > }
    > ```
4. 代码风格
   1. 提示词，比如Google Style Guide
   2. 项目现有的编码风格和约定
5. 环境信息
   1. 操作系统
   2. 工作目录
   3. Shell类型
6. 特定技术栈指南
   1. vue 还是 react
   2. maven 还是gradle
   3. activiti、flowable 还是 camunda
7. 计划制定与分解
   > **示例**：（来自 `Claude Code\claude-code-system-prompt.txt`）
   > `<example>`
   > `user: Run the build and fix any type errors`
   > `assistant: I'm going to use the TodoWrite tool to write the following items to the todo list:`
   > `- Run the build`
   > `- Fix any type errors`
   > `...`
   > `</example>`
   > **中文角度解读**：用户提出一个包含多个步骤的任务，AI立即使用`TodoWrite`工具将其分解为清晰的待办事项，并向用户展示。
   > **目的**：将抽象任务具体化、流程化。通过强制使用任务列表，AI能够系统地跟踪每个子任务的状态（待办、进行中、已完成），避免遗漏，并为用户提供了极高的透明度。
8. 其它规范
   1. 安全约束
   2. 道德约束
   3. 格式约束
9. 补充信息
   1. 知识库时效，补充最新的版本号，最新代码调用方式
   2. 大模型问题幻觉

## 其它
好的，这是一个非常深刻且重要的问题。代码的调整和优化远不止是修复 Bug 或增加功能，它是一个在多个维度之间进行权衡（Trade-off）和优化的复杂过程。

以下我将从 **代码微观、架构中观、系统宏观、流程与协作** 四个层面，列出代码可以调整的维度，并说明原因。

---

### 一、 代码微观层面 (Micro-Level)

这个层面关注的是代码的“细胞”——函数、类、模块的内部质量。

#### 1. 可读性 (Readability)
*   **是什么**：代码是否清晰、易于理解，就像在阅读一篇流畅的文章。
*   **为什么重要**：代码的生命周期中，被阅读的次数远超被编写的次数。高可读性可以极大地降低维护成本、减少新人上手难度、降低因误解代码而引入新 Bug 的风险。**“代码是写给人读的，顺便给机器执行。”**
*   **如何调整**：
   *   **命名规范**：使用有意义、无歧义的变量名、函数名、类名（如 `calculate_interest` 而非 `calc_int`）。
   *   **代码注释**：注释“为什么”这么做，而不是“做什么”（代码本身应能说明做什么）。
   *   **代码格式化**：保持一致的缩进、空格、换行，利用 `Prettier`、`Black` 等工具自动化。
   *   **简化逻辑**：避免过深的嵌套（如多层 `if-else`），使用卫语句（Guard Clauses）提前返回。

#### 2. 可维护性 (Maintainability)
*   **是什么**：代码是否容易被修改、扩展和修复。它与可读性高度相关，但更侧重于结构。
*   **为什么重要**：需求总是在变化。低可维护性的代码（“屎山”）会让任何微小的改动都变成一场灾难，耗费大量时间，且风险极高。
*   **如何调整**：
   *   **遵守 DRY 原则 (Don't Repeat Yourself)**：将重复的代码抽取成函数或类。
   *   **遵守 KISS 原则 (Keep It Simple, Stupid)**：用最简单直接的方式解决问题，避免过度设计。
   *   **高内聚，低耦合**：让模块内部功能紧密相关，模块之间依赖尽可能少。
   *   **函数单一职责**：一个函数只做一件事情，并把它做好。

#### 3. 性能与效率 (Performance & Efficiency)
*   **是什么**：代码执行的速度（时间复杂度）和消耗的资源（如内存、CPU，即空间复杂度）。
*   **为什么重要**：直接影响用户体验和服务器成本。一个慢查询、一个内存泄漏，都可能导致系统崩溃或运营成本飙升。
*   **如何调整**：
   *   **算法优化**：选择更优的时间/空间复杂度算法（如用哈希表查找替代列表遍历）。
   *   **数据结构选择**：根据场景选择最合适的数据结构（如 `List` vs `Set` vs `Dict`）。
   *   **I/O 操作优化**：减少数据库查询次数、合并文件读写、使用缓存。
   *   **并发/并行**：利用多线程、多进程或异步 I/O 提升吞吐量。
   *   **内存管理**：避免内存泄漏，及时释放不再使用的资源。

---

### 二、 架构中观层面 (Meso-Level)

这个层面关注的是模块、服务之间的组织方式和交互关系。

#### 4. 架构与设计 (Architecture & Design)
*   **是什么**：系统的整体结构、组件划分以及它们之间的协作模式。
*   **为什么重要**：好的架构决定了系统的上限。它关乎系统的可扩展性、可维护性和开发效率。架构一旦确定，后期修改成本极高。
*   **如何调整**：
   *   **设计模式应用**：合理使用工厂模式、策略模式、观察者模式等解决特定问题。
   *   **遵循 SOLID 原则**：单一职责、开闭、里氏替换、接口隔离、依赖倒置，是构建稳定、灵活软件的基石。
   *   **分层架构**：如经典的表示层、业务逻辑层、数据访问层，使职责清晰。
   *   **服务化/微服务化**：将单体应用拆分为独立部署、独立扩展的服务，降低耦合度，提升团队并行开发效率。

#### 5. 可扩展性 (Extensibility)
*   **是什么**：在不修改现有核心代码的情况下，为系统增加新功能的能力。
*   **为什么重要**：业务发展必然带来新需求。良好的可扩展性使得系统能“拥抱变化”，快速响应市场需求，而不是每次都进行伤筋动骨的大手术。
*   **如何调整**：
   *   **插件化设计**：定义清晰的接口和扩展点，让新功能以插件形式接入。
   *   **面向接口编程**：依赖抽象而非具体实现，方便替换和扩展。
   *   **配置化**：将易变的业务逻辑、规则、参数提取到配置文件或配置中心，实现动态调整。
   *   **事件驱动架构**：通过消息队列解耦服务，新服务可以订阅感兴趣的事件来扩展功能。

#### 6. 可测试性 (Testability)
*   **是什么**：代码是否容易被自动化测试（单元测试、集成测试等）。
*   **为什么重要**：没有测试的代码是“易碎”的。高可测试性是实现持续集成、保证代码质量、让开发者有信心重构的前提。
*   **如何调整**：
   *   **依赖注入 (Dependency Injection)**：将外部依赖（如数据库连接、API客户端）作为参数传入，而不是在内部创建，方便在测试时替换为 Mock 对象。
   *   **纯函数**：尽可能编写没有副作用的纯函数，它们的输出只依赖于输入，极易测试。
   *   **减少全局状态**：全局变量和单例模式会使测试变得困难，因为测试用例之间会相互影响。

---

### 三、 系统宏观层面 (Macro-Level)

这个层面关注的是整个系统在生产环境中的表现。

#### 7. 可靠性与健壮性 (Reliability & Robustness)
*   **是什么**：系统在面临异常输入、硬件故障、网络问题等非预期情况时，维持正常运行或优雅降级的能力。
*   **为什么重要**：决定了系统的稳定性和用户信任度。一个频繁崩溃或数据出错的系统是不可用的。
*   **如何调整**：
   *   **错误处理**：完善的 `try-catch` 机制，对所有外部调用和用户输入做防御性校验。
   *   **容错机制**：如重试（Retry）、熔断（Circuit Breaking）、限流（Rate Limiting）、降级（Fallback）。
   *   **数据校验与一致性**：严格的输入验证，使用数据库事务保证数据操作的原子性。
   *   **日志与监控**：详尽的日志记录问题现场，完善的监控告警系统及时发现问题。

#### 8. 安全性 (Security)
*   **是什么**：保护系统免受恶意攻击（如 SQL 注入、XSS、CSRF）、防止数据泄露的能力。
*   **为什么重要**：安全性是系统的生命线。一次安全事故可能导致用户数据泄露、公司声誉受损，甚至法律责任。
*   **如何调整**：
   *   **输入验证**：永远不要信任用户的输入，对所有输入进行严格的校验和清理。
   *   **认证与授权**：确保用户是谁（Authentication），并只允许他们访问其有权限的资源（Authorization）。
   *   **依赖管理**：定期扫描并更新第三方库，修复已知的安全漏洞。
   *   **数据加密**：对敏感数据（如密码、个人信息）进行加密存储和传输。

#### 9. 可伸缩性与弹性 (Scalability & Elasticity)
*   **是什么**：
   *   **可伸缩性**：系统通过增加资源（垂直扩展：更强的服务器；水平扩展：更多的服务器）来处理不断增长的负载的能力。
   *   **弹性**：系统根据负载自动增减资源的能力。
*   **为什么重要**：应对业务增长（如用户量激增、大促活动）的关键。弹性则能优化成本，按需使用资源。
*   **如何调整**：
   *   **无状态服务设计**：将状态（如用户会话）外部化存储（如 Redis），使得服务可以任意水平扩展。
   *   **负载均衡**：将请求分发到多个服务器实例。
   *   **数据库扩展**：读写分离、分库分表。
   *   **异步化和队列**：使用消息队列削峰填谷，将非核心、耗时的任务异步处理。

---

### 四、 流程与协作层面 (Process & Collaboration)

这个层面关注的是代码作为团队协作产物的属性。

#### 10. 规范性与一致性 (Standardization & Consistency)
*   **是什么**：整个团队或项目遵循统一的编码风格、设计模式、工具和提交流程。
*   **为什么重要**：降低沟通成本和认知负荷。当所有代码看起来都像一个人写的时候，任何人都可以快速地理解和修改任何部分的代码。
*   **如何调整**：
   *   **制定编码规范**：并使用 `ESLint`、`Checkstyle` 等工具强制执行。
   *   **代码审查 (Code Review)**：作为强制流程，传播知识、统一标准、发现潜在问题。
   *   **统一技术栈和工具链**：避免项目中出现多种语言、框架、库做同一件事。
   *   **版本控制规范**：如 Git Flow、Semantic Versioning、清晰的 Commit Message 格式。

#### 11. 可部署性与运维性 (Deployability & Operability)
*   **是什么**：代码从开发环境到生产环境的自动化程度，以及在生产环境中监控、排错的便捷性。
*   **为什么重要**：这是 DevOps 理念的核心。它决定了产品迭代的速度和线上问题的响应速度。
*   **如何调整**：
   *   **持续集成/持续部署 (CI/CD)**：自动化构建、测试、部署流程。
   *   **容器化**：使用 Docker 封装应用和其环境，保证环境一致性。
   *   **基础设施即代码 (IaC)**：使用 `Terraform`、`Ansible` 等工具管理服务器配置。
   *   **可观测性 (Observability)**：提供丰富的日志（Logging）、指标（Metrics）和追踪（Tracing），便于深入了解系统运行状态。

#### 12. 成本效益 (Cost-Effectiveness)
*   **是什么**：在满足业务需求的前提下，综合考虑开发成本、运维成本和时间成本，做出最合理的选择。
*   **为什么重要**：技术服务于业务。追求“完美”的代码而延误上线时间，或者为了节省一点服务器费用而花费大量开发时间，都是不可取的。
*   **如何调整**：
   *   **不过早优化**：在性能瓶颈真正出现前，不要花费过多精力进行优化。
   *   **技术选型**：选择团队熟悉、社区成熟的技术，而不是盲目追新。
   *   **MVP (最小可行产品) 思维**：先快速上线核心功能，再根据反馈迭代。
   *   **评估“轮子”**：权衡自研和使用成熟的第三方服务（Build vs. Buy）。

### 总结

调整代码是一个多维度的决策过程，优秀的工程师懂得在这些维度之间找到最佳平衡点。

| 层面 | 维度 | 关注点 |
| :--- | :--- | :--- |
| **微观** | 可读性、可维护性、性能 | 代码本身是否优雅、高效 |
| **中观** | 架构设计、可扩展性、可测试性 | 模块和组件如何组织与协作 |
| **宏观** | 可靠性、安全性、可伸缩性 | 系统在生产环境中的表现 |
| **流程** | 规范性、可部署性、成本效益 | 团队如何高效、经济地交付价值 |

在项目的不同阶段，这些维度的优先级也不同。例如，初创公司可能更看重**开发速度（成本效益）**，而金融机构则永远将**安全性**和**可靠性**放在首位。理解这些维度，能帮助你更全面地思考和提升代码质量。