# JavaScript ES6 (ECMAScript 2015) 核心特性分类详解

## 目录

1.  [引言：ES6 的重要性](#引言)
2.  [新的变量声明与作用域](#1-新的变量声明与作用域)
    *   `let` 与块级作用域
    *   `const` 与常量
    *   块级作用域的重要性
3.  [解构赋值 (Destructuring Assignment)](#2-解构赋值)
    *   数组解构
    *   对象解构
    *   函数参数解构
4.  [函数扩展 (Function Extensions)](#3-函数扩展)
    *   箭头函数 (Arrow Functions)
    *   函数参数默认值
    *   剩余参数 (Rest Parameters)
    *   展开语法 (Spread Syntax)
5.  [类与对象 (Classes & Objects)](#4-类与对象)
    *   `class` 语法糖
    *   `constructor`, `extends`, `super`
    *   对象字面量增强
    *   `Symbol`: 新的原始类型
6.  [异步编程的革命](#5-异步编程的革命)
    *   `Promise` 对象
    *   `async / await` (ES2017, 但与 Promise 紧密相关)
7.  [模块化 (Modules)](#6-模块化)
    *   `export` (导出)
    *   `import` (导入)
8.  [新的数据结构](#7-新的数据结构)
    *   `Set`
    *   `Map`
    *   `WeakSet` 和 `WeakMap`
9.  [字符串与模板](#8-字符串与模板)
    *   模板字符串 (Template Literals)
    *   新的字符串方法
10. [数组扩展 (Array Extensions)](#9-数组扩展)
    *   `Array.from()`
    *   `Array.of()`
    *   新的实例方法: `find()`, `findIndex()`, `includes()`, `fill()` 等
11. [迭代器与生成器 (Iterators & Generators)](#10-迭代器与生成器)
    *   迭代器协议 (Iterator Protocol)
    *   `for...of` 循环
    *   生成器 (`function*` 和 `yield`)
12. [代理与反射 (Proxy & Reflect)](#11-代理与反射)
    *   `Proxy`
    *   `Reflect`
13. [总结](#总结)

---

## <a name="引言"></a> 引言：ES6 的重要性

ES6 (ECMAScript 2015) 是 JavaScript 语言的一次重大更新，也是自 1999 年 ES3 发布以来最重要的一次版本迭代。它引入了大量新特性，旨在解决原有语言的痛点，提升开发效率，并使 JavaScript 能够更好地构建复杂、大规模的应用程序。ES6 的出现标志着现代 JavaScript 的开端。

---

## <a name="1-新的变量声明与作用域"></a> 1. 新的变量声明与作用域

ES6 引入了 `let` 和 `const`，提供了块级作用域，从根本上改变了 JavaScript 的变量声明方式。

### `let` 与块级作用域

`let` 声明的变量只在它所在的代码块（`{...}`）内有效。

**痛点 (ES5):** `var` 只有函数作用域和全局作用域，没有块级作用域，容易导致变量提升和变量污染。

```javascript
// ES5 - var 的问题
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // 输出三次 3
  }, 100);
}
console.log(i); // 3, 变量泄露到循环外

// ES6 - let 解决
for (let j = 0; j < 3; j++) {
  setTimeout(function() {
    console.log(j); // 依次输出 0, 1, 2
  }, 100);
}
// console.log(j); // ReferenceError: j is not defined
```

**关键特性:**
*   **块级作用域**: 作用域限制在 `{}` 内。
*   **无变量提升**: 必须先声明后使用，否则会进入“暂时性死区”(TDZ)。
*   **不可重复声明**: 在同一作用域内，不能重复声明同一个变量。

### `const` 与常量

`const` 用于声明一个只读的常量。一旦声明，常量的值就不能改变。

```javascript
const PI = 3.14159;
// PI = 3; // TypeError: Assignment to constant variable.

// 注意：对于对象和数组，const 保证的是变量指向的内存地址不变，
// 而不是数据结构的内容不变。
const person = { name: 'Alice' };
person.name = 'Bob'; // 这是允许的
console.log(person.name); // 'Bob'

// person = { name: 'Charlie' }; // TypeError，因为改变了引用地址
```

**使用建议**: 优先使用 `const`，当变量需要被重新赋值时才使用 `let`。这能让代码更具可读性和健壮性。

---

## <a name="2-解构赋值"></a> 2. 解构赋值 (Destructuring Assignment)

一种从数组或对象中提取值并赋给变量的便捷语法。

### 数组解构

```javascript
const numbers = [10, 20, 30];
const [a, b, c] = numbers;
console.log(a, b, c); // 10 20 30

// 交换变量
let x = 1, y = 2;
[x, y] = [y, x];
console.log(x, y); // 2 1

// 忽略某些值
const [first, , third] = numbers;
console.log(first, third); // 10 30
```

### 对象解构

```javascript
const user = {
  id: 42,
  is_admin: true,
  info: {
    name: 'John Doe',
    age: 34
  }
};

// 基础解构
const { id, is_admin } = user;
console.log(id, is_admin); // 42 true

// 重命名变量
const { info: userInfo } = user;
console.log(userInfo); // { name: 'John Doe', age: 34 }

// 嵌套解构
const { info: { name, age } } = user;
console.log(name, age); // 'John Doe' 34

// 设置默认值
const { nickname = 'Guest' } = user;
console.log(nickname); // 'Guest'
```

---

## <a name="3-函数扩展"></a> 3. 函数扩展

### 箭头函数 (Arrow Functions)

箭头函数提供了更简洁的函数写法，并解决了 `this` 指向的经典问题。

**关键特性:**
1.  **简洁语法**: `(params) => expression` 或 `(params) => { statements }`。
2.  **词法 `this`**: 箭头函数没有自己的 `this`，它会捕获其所在上下文的 `this` 值。

```javascript
// ES5 this 问题
function Timer() {
  this.seconds = 0;
  var self = this; // 需要一个临时变量保存 this
  setInterval(function() {
    self.seconds++;
    console.log(self.seconds);
  }, 1000);
}
// var timer = new Timer();

// ES6 箭头函数解决
function TimerES6() {
  this.seconds = 0;
  setInterval(() => {
    this.seconds++; // 这里的 this 正确指向 TimerES6 实例
    console.log(this.seconds);
  }, 1000);
}
// var timer6 = new TimerES6();
```

**注意**: 箭头函数不能用作构造函数，也没有 `arguments` 对象。

### 函数参数默认值

```javascript
function greet(name = 'Guest', message = 'Hello') {
  console.log(`${message}, ${name}!`);
}
greet(); // Hello, Guest!
greet('Alice'); // Hello, Alice!
greet('Bob', 'Hi'); // Hi, Bob!
```

### 剩余参数 (Rest Parameters)

使用 `...` 将一个不定数量的参数表示为一个数组。

```javascript
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}
console.log(sum(1, 2, 3)); // 6
console.log(sum(10, 20, 30, 40)); // 100
```

### 展开语法 (Spread Syntax)

同样使用 `...`，但用于将数组或对象“展开”成独立的元素。

```javascript
// 数组展开
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]

// 函数调用
const nums = [9, 4, 7];
Math.max(...nums); // 等同于 Math.max(9, 4, 7)

// 对象展开 (ES2018)
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }
```

---

## <a name="4-类与对象"></a> 4. 类与对象

### `class` 语法糖

ES6 提供了 `class` 关键字，作为创建对象的模板。它本质上是原型继承的语法糖，让代码更清晰，更像传统的面向对象语言。

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // 调用父类的 constructor
    this.breed = breed;
  }

  speak() {
    console.log(`${this.name} barks.`);
  }
}

const myDog = new Dog('Rex', 'German Shepherd');
myDog.speak(); // Rex barks.
```

### 对象字面量增强

```javascript
const name = 'Alice';
const age = 25;

// 属性简写
const person = { name, age }; // 等同于 { name: name, age: age }

// 方法简写
const machine = {
  start() { // 等同于 start: function() { ... }
    console.log('Machine started.');
  }
};

// 计算属性名
const propName = 'dynamic_prop';
const obj = {
  [propName]: 'Hello World'
};
console.log(obj.dynamic_prop); // Hello World
```

### `Symbol`: 新的原始类型

`Symbol()` 函数会返回一个唯一的、不可变的值，主要用于创建对象的唯一属性名，避免属性名冲突。

```javascript
const idSymbol = Symbol('id');
const user = {
  name: 'John',
  [idSymbol]: 123
};

console.log(user[idSymbol]); // 123
// Symbol 属性不会被 for...in, Object.keys() 遍历到
```

---

## <a name="5-异步编程的革命"></a> 5. 异步编程的革命

### `Promise` 对象

`Promise` 是一个用于处理异步操作的对象，它代表了一个尚未完成但最终会完成（或失败）的操作。它解决了“回调地狱”（Callback Hell）的问题。

一个 `Promise` 有三种状态：
*   **pending**: 初始状态，既不是成功，也不是失败状态。
*   **fulfilled**: 意味着操作成功完成。
*   **rejected**: 意味着操作失败。

```javascript
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = Math.random() > 0.5;
      if (success) {
        resolve({ data: 'Some data from server' });
      } else {
        reject(new Error('Failed to fetch data'));
      }
    }, 1000);
  });
}

fetchData()
  .then(response => {
    console.log('Success:', response.data);
  })
  .catch(error => {
    console.error('Error:', error.message);
  })
  .finally(() => {
    console.log('Operation finished.');
  });
```

### `async / await` (ES2017)

虽然 `async/await` 是 ES2017 的特性，但它完全基于 `Promise`，是使用 `Promise` 的最佳方式，使异步代码看起来像同步代码。

*   `async` 关键字用于声明一个异步函数，该函数隐式返回一个 `Promise`。
*   `await` 关键字只能在 `async` 函数中使用，它会暂停函数的执行，等待 `Promise` 被解决。

```javascript
async function processData() {
  try {
    console.log('Fetching data...');
    const response = await fetchData(); // 等待 Promise 完成
    console.log('Success:', response.data);
    return response.data;
  } catch (error) {
    console.error('Error:', error.message);
  } finally {
    console.log('Operation finished.');
  }
}

processData();
```

---

## <a name="6-模块化"></a> 6. 模块化

ES6 引入了官方的模块化标准，使得 JavaScript 可以像其他语言一样，将代码分割成可重用的模块。

### `export` (导出)

一个文件可以导出多个变量、函数或类。

```javascript
// file: utils.js

// 命名导出
export const PI = 3.14;
export function add(a, b) {
  return a + b;
}

// 默认导出 (每个模块只能有一个)
export default function multiply(a, b) {
  return a * b;
}
```

### `import` (导入)

在另一个文件中导入需要的功能。

```javascript
// file: main.js

// 导入命名导出的模块
import { PI, add } from './utils.js';

// 导入默认导出的模块 (可以任意命名)
import multiplyNumbers from './utils.js';

// 混合导入
import multiply, { PI, add as sum } from './utils.js'; // 使用 as 重命名

console.log(PI); // 3.14
console.log(sum(2, 3)); // 5
console.log(multiply(2, 3)); // 6
```
**注意**: ES6 模块默认在严格模式下运行。

---

## <a name="7-新的数据结构"></a> 7. 新的数据结构

### `Set`

成员值都是唯一的数据结构，类似于数组，但没有重复值。

```javascript
const mySet = new Set([1, 2, 2, 3, 4, 4]);
mySet.add(5);
mySet.add(1); // 无效，因为 1 已存在

console.log(mySet); // Set(5) { 1, 2, 3, 4, 5 }
console.log(mySet.has(3)); // true
mySet.delete(2);

// 数组去重
const uniqueNumbers = [...new Set([1, 2, 2, 3])]; // [1, 2, 3]
```

### `Map`

键值对的集合，类似于对象，但键的类型不限于字符串，可以是任何类型（包括对象）。

```javascript
const myMap = new Map();
const keyObject = { id: 1 };

myMap.set('name', 'Alice');
myMap.set(keyObject, 'Some value');

console.log(myMap.get('name')); // 'Alice'
console.log(myMap.get(keyObject)); // 'Some value'
console.log(myMap.size); // 2
```

### `WeakSet` 和 `WeakMap`

`WeakSet` 和 `WeakMap` 是 `Set` 和 `Map` 的“弱引用”版本。它们的成员/键必须是对象，并且如果该对象没有其他引用，垃圾回收机制会自动清除它，有助于防止内存泄漏。

---

## <a name="8-字符串与模板"></a> 8. 字符串与模板

### 模板字符串 (Template Literals)

使用反引号 (`` ` ``) 定义字符串，可以轻松实现多行字符串和内嵌变量。

```javascript
const name = 'World';
const greeting = `Hello, ${name}!
This is a multi-line string.`;

console.log(greeting);
// 输出:
// Hello, World!
// This is a multi-line string.
```

### 新的字符串方法

*   `includes(str)`: 判断是否包含指定字符串。
*   `startsWith(str)`: 判断是否以指定字符串开头。
*   `endsWith(str)`: 判断是否以指定字符串结尾。
*   `repeat(n)`: 将字符串重复 n 次。

```javascript
const text = 'Hello world';
console.log(text.includes('world'));    // true
console.log(text.startsWith('Hello')); // true
console.log('hi'.repeat(3));           // 'hihihi'
```

---

## <a name="9-数组扩展"></a> 9. 数组扩展

### `Array.from()`
将类数组对象（如 `arguments`, `NodeList`）或可迭代对象转换为真正的数组。

```javascript
const nodeList = document.querySelectorAll('div');
const divArray = Array.from(nodeList); // 现在可以使用 map, filter 等数组方法

function f() {
  const args = Array.from(arguments);
  console.log(args);
}
f(1, 2, 3); // [1, 2, 3]
```

### `Array.of()`
将一组值转换为数组，弥补 `Array()` 构造函数的不足。

```javascript
Array.of(3, 11, 8); // [3, 11, 8]
Array(3);           // [ , , ] (创建一个长度为 3 的空数组)
```

### 新的实例方法

*   `find(callback)`: 返回第一个满足条件的元素。
*   `findIndex(callback)`: 返回第一个满足条件的元素的索引。
*   `includes(value)`: 判断数组是否包含某个值。
*   `fill(value, start, end)`: 用一个固定值填充数组。
*   `keys()`, `values()`, `entries()`: 返回迭代器对象。

---

## <a name="10-迭代器与生成器"></a> 10. 迭代器与生成器

### 迭代器协议 (Iterator Protocol)

ES6 定义了一个标准的迭代器协议。任何对象只要实现了 `[Symbol.iterator]` 方法，并且该方法返回一个包含 `next()` 方法的对象，那么这个对象就是“可迭代的”。

### `for...of` 循环

`for...of` 循环专门用于遍历可迭代对象（如数组、字符串、`Map`、`Set` 等）。

```javascript
const colors = ['red', 'green', 'blue'];
for (const color of colors) {
  console.log(color);
}
// red
// green
// blue
```

### 生成器 (`function*` 和 `yield`)

生成器是一种特殊的函数，可以暂停执行并在稍后恢复。它使得创建自定义迭代器变得非常简单。

```javascript
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();

console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
console.log(gen.next().done);  // true

// 也可以直接用 for...of 遍历
for (const num of numberGenerator()) {
  console.log(num);
}
```
生成器在实现高级异步控制流（如 Redux Saga）和处理大数据流时非常有用。

---

## <a name="11-代理与反射"></a> 11. 代理与反射

这是 ES6 提供的元编程（metaprogramming）能力。

### `Proxy`
`Proxy` 用于创建一个对象的代理，从而可以拦截并自定义该对象上的基本操作（如属性查找、赋值、函数调用等）。

```javascript
const target = {
  message: "hello"
};

const handler = {
  get(target, prop, receiver) {
    if (prop in target) {
      return target[prop];
    } else {
      return "Property not found!";
    }
  }
};

const p = new Proxy(target, handler);
console.log(p.message); // hello
console.log(p.nonExistent); // Property not found!
```

### `Reflect`
`Reflect` 是一个内置对象，它提供了一组与 `Proxy` `handler` 方法同名的方法，相当于执行了默认的对象操作。它使得自定义操作与默认操作之间的交互更加自然。

```javascript
const handlerWithReflect = {
  get(target, prop, receiver) {
    console.log(`Getting property "${prop}"`);
    return Reflect.get(target, prop, receiver); // 执行默认的 get 操作
  }
};
```

---

## <a name="总结"></a> 总结

ES6 是 JavaScript 发展史上的一个重要里程碑。它不仅通过 `let/const`、箭头函数和类等特性提升了代码的可读性和可维护性，还通过 `Promise`、模块化等功能为构建大型、复杂的现代 Web 应用奠定了坚实的基础。掌握 ES6 是每一位现代 JavaScript 开发者的必备技能。